{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/grid_core/ui.grid_core.column_fixing.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getOuterWidth } from \"../../core/utils/size\";\nimport $ from \"../../core/renderer\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport { name as wheelEventName } from \"../../events/core/wheel\";\nimport messageLocalization from \"../../localization/message\";\nimport gridCoreUtils from \"../grid_core/ui.grid_core.utils\";\nimport { isDefined } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport browser from \"../../core/utils/browser\";\nimport { getBoundingRect } from \"../../core/utils/position\";\nimport { move } from \"../../animation/translator\";\nimport Scrollable from \"../scroll_view/ui.scrollable\";\nimport { when } from \"../../core/utils/deferred\";\nvar CONTENT_CLASS = \"content\";\nvar CONTENT_FIXED_CLASS = \"content-fixed\";\nvar MASTER_DETAIL_CELL_CLASS = \"dx-master-detail-cell\";\nvar FIRST_CELL_CLASS = \"dx-first-cell\";\nvar LAST_CELL_CLASS = \"dx-last-cell\";\nvar HOVER_STATE_CLASS = \"dx-state-hover\";\nvar FIXED_COL_CLASS = \"dx-col-fixed\";\nvar FIXED_COLUMNS_CLASS = \"dx-fixed-columns\";\nvar POINTER_EVENTS_NONE_CLASS = \"dx-pointer-events-none\";\nvar COMMAND_TRANSPARENT = \"transparent\";\nvar GROUP_ROW_CLASS = \"dx-group-row\";\nvar DETAIL_ROW_CLASS = \"dx-master-detail-row\";\nvar getTransparentColumnIndex = function getTransparentColumnIndex(fixedColumns) {\n  var transparentColumnIndex = -1;\n  each(fixedColumns, function (index, column) {\n    if (column.command === COMMAND_TRANSPARENT) {\n      transparentColumnIndex = index;\n      return false;\n    }\n  });\n  return transparentColumnIndex;\n};\nvar normalizeColumnWidths = function normalizeColumnWidths(fixedColumns, widths, fixedWidths) {\n  var fixedColumnIndex = 0;\n  if (fixedColumns && widths && fixedWidths) {\n    for (var i = 0; i < fixedColumns.length; i++) {\n      if (fixedColumns[i].command === COMMAND_TRANSPARENT) {\n        fixedColumnIndex += fixedColumns[i].colspan;\n      } else {\n        if (widths[fixedColumnIndex] < fixedWidths[i]) {\n          widths[fixedColumnIndex] = fixedWidths[i];\n        }\n        fixedColumnIndex++;\n      }\n    }\n  }\n  return widths;\n};\nvar baseFixedColumns = {\n  init: function init() {\n    this.callBase();\n    this._isFixedTableRendering = false;\n    this._isFixedColumns = false;\n  },\n  _createCol: function _createCol(column) {\n    return this.callBase(column).toggleClass(FIXED_COL_CLASS, !!(this._isFixedTableRendering && (column.fixed || column.command && column.command !== COMMAND_TRANSPARENT)));\n  },\n  _correctColumnIndicesForFixedColumns: function _correctColumnIndicesForFixedColumns(fixedColumns, change) {\n    var transparentColumnIndex = getTransparentColumnIndex(fixedColumns);\n    var transparentColspan = fixedColumns[transparentColumnIndex].colspan;\n    var columnIndices = change && change.columnIndices;\n    if (columnIndices) {\n      change.columnIndices = columnIndices.map(function (columnIndices) {\n        if (columnIndices) {\n          return columnIndices.map(function (columnIndex) {\n            if (columnIndex < transparentColumnIndex) {\n              return columnIndex;\n            } else if (columnIndex >= transparentColumnIndex + transparentColspan) {\n              return columnIndex - transparentColspan + 1;\n            }\n            return -1;\n          }).filter(function (columnIndex) {\n            return columnIndex >= 0;\n          });\n        }\n      });\n    }\n  },\n  _partialUpdateFixedTable: function _partialUpdateFixedTable(fixedColumns) {\n    var fixedTableElement = this._fixedTableElement;\n    var $rows = this._getRowElementsCore(fixedTableElement);\n    var $colgroup = fixedTableElement.children(\"colgroup\");\n    $colgroup.replaceWith(this._createColGroup(fixedColumns));\n    for (var i = 0; i < $rows.length; i++) {\n      this._partialUpdateFixedRow($($rows[i]), fixedColumns);\n    }\n  },\n  _partialUpdateFixedRow: function _partialUpdateFixedRow($row, fixedColumns) {\n    var cellElements = $row.get(0).childNodes;\n    var transparentColumnIndex = getTransparentColumnIndex(fixedColumns);\n    var transparentColumn = fixedColumns[transparentColumnIndex];\n    var columnIndexOffset = this._columnsController.getColumnIndexOffset();\n    var groupCellOptions;\n    var colIndex = columnIndexOffset + 1;\n    var colspan = transparentColumn.colspan;\n    if ($row.hasClass(DETAIL_ROW_CLASS)) {\n      var _this$_columnsControl;\n      cellElements[0].setAttribute(\"colspan\", null === (_this$_columnsControl = this._columnsController.getVisibleColumns()) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.length);\n      return;\n    }\n    if ($row.hasClass(GROUP_ROW_CLASS)) {\n      groupCellOptions = this._getGroupCellOptions({\n        row: $row.data(\"options\"),\n        columns: this._columnsController.getVisibleColumns()\n      });\n      colspan = groupCellOptions.colspan - Math.max(0, cellElements.length - (groupCellOptions.columnIndex + 2));\n    }\n    for (var j = 0; j < cellElements.length; j++) {\n      var needUpdateColspan = groupCellOptions ? j === groupCellOptions.columnIndex + 1 : j === transparentColumnIndex;\n      cellElements[j].setAttribute(\"aria-colindex\", colIndex);\n      if (needUpdateColspan) {\n        cellElements[j].setAttribute(\"colspan\", colspan);\n        colIndex += colspan;\n      } else {\n        colIndex++;\n      }\n    }\n  },\n  _renderTable: function _renderTable(options) {\n    var _this = this;\n    var $fixedTable;\n    var fixedColumns = this.getFixedColumns();\n    this._isFixedColumns = !!fixedColumns.length;\n    var $table = this.callBase(options);\n    if (this._isFixedColumns) {\n      var change = null === options || void 0 === options ? void 0 : options.change;\n      this._isFixedTableRendering = true;\n      if (null !== change && void 0 !== change && change.virtualColumnsScrolling && true !== this.option(\"scrolling.legacyMode\")) {\n        this._partialUpdateFixedTable(fixedColumns);\n        this._isFixedTableRendering = false;\n      } else {\n        var columnIndices = null === change || void 0 === change ? void 0 : change.columnIndices;\n        this._correctColumnIndicesForFixedColumns(fixedColumns, change);\n        $fixedTable = this._createTable(fixedColumns);\n        this._renderRows($fixedTable, extend({}, options, {\n          columns: fixedColumns\n        }));\n        when(this._updateContent($fixedTable, change)).done(function () {\n          _this._isFixedTableRendering = false;\n        });\n        if (columnIndices) {\n          change.columnIndices = columnIndices;\n        }\n      }\n    } else {\n      this._fixedTableElement && this._fixedTableElement.parent().remove();\n      this._fixedTableElement = null;\n    }\n    return $table;\n  },\n  _renderRow: function _renderRow($table, options) {\n    var fixedCorrection;\n    var cells = options.row.cells;\n    this.callBase.apply(this, arguments);\n    if (this._isFixedTableRendering && cells && cells.length) {\n      fixedCorrection = 0;\n      var fixedCells = options.row.cells || [];\n      cells = cells.slice();\n      options.row.cells = cells;\n      for (var i = 0; i < fixedCells.length; i++) {\n        if (fixedCells[i].column && fixedCells[i].column.command === COMMAND_TRANSPARENT) {\n          fixedCorrection = (fixedCells[i].column.colspan || 1) - 1;\n          continue;\n        }\n        cells[i + fixedCorrection] = fixedCells[i];\n      }\n    }\n  },\n  _createCell: function _createCell(options) {\n    var that = this;\n    var column = options.column;\n    var columnCommand = column && column.command;\n    var rowType = options.rowType;\n    var $cell = that.callBase.apply(that, arguments);\n    var fixedColumns;\n    var prevFixedColumn;\n    var transparentColumnIndex;\n    if (that._isFixedTableRendering || \"filter\" === rowType) {\n      fixedColumns = that.getFixedColumns();\n      transparentColumnIndex = getTransparentColumnIndex(fixedColumns);\n      prevFixedColumn = fixedColumns[transparentColumnIndex - 1];\n    }\n    if (that._isFixedTableRendering) {\n      if (columnCommand === COMMAND_TRANSPARENT) {\n        $cell.addClass(POINTER_EVENTS_NONE_CLASS).toggleClass(FIRST_CELL_CLASS, 0 === transparentColumnIndex || prevFixedColumn && \"expand\" === prevFixedColumn.command).toggleClass(LAST_CELL_CLASS, fixedColumns.length && transparentColumnIndex === fixedColumns.length - 1);\n        if (\"freeSpace\" !== rowType) {\n          gridCoreUtils.setEmptyText($cell);\n        }\n      }\n    } else if (\"filter\" === rowType) {\n      $cell.toggleClass(FIRST_CELL_CLASS, options.columnIndex === transparentColumnIndex);\n    }\n    var isRowAltStyle = that.option(\"rowAlternationEnabled\") && options.isAltRow;\n    var isSelectAllCell = \"multiple\" === that.option(\"selection.mode\") && 0 === options.columnIndex && \"header\" === options.rowType;\n    if (browser.mozilla && options.column.fixed && \"group\" !== options.rowType && !isRowAltStyle && !isSelectAllCell) {\n      $cell.addClass(FIXED_COL_CLASS);\n    }\n    return $cell;\n  },\n  _wrapTableInScrollContainer: function _wrapTableInScrollContainer() {\n    var $scrollContainer = this.callBase.apply(this, arguments);\n    if (this._isFixedTableRendering) {\n      $scrollContainer.addClass(this.addWidgetPrefix(CONTENT_FIXED_CLASS));\n    }\n    return $scrollContainer;\n  },\n  _renderCellContent: function _renderCellContent($cell, options) {\n    var isEmptyCell;\n    var column = options.column;\n    var isFixedTableRendering = this._isFixedTableRendering;\n    var isGroupCell = \"group\" === options.rowType && isDefined(column.groupIndex);\n    if (isFixedTableRendering && isGroupCell && !column.command && !column.groupCellTemplate) {\n      $cell.css(\"pointerEvents\", \"none\");\n    }\n    if (!isFixedTableRendering && this._isFixedColumns) {\n      isEmptyCell = column.fixed || column.command && false !== column.fixed;\n      if (isGroupCell) {\n        isEmptyCell = false;\n        if (options.row.summaryCells && options.row.summaryCells.length) {\n          var columns = this._columnsController.getVisibleColumns();\n          var alignByFixedColumnCellCount = this._getAlignByColumnCellCount ? this._getAlignByColumnCellCount(column.colspan, {\n            columns: columns,\n            row: options.row,\n            isFixed: true\n          }) : 0;\n          if (alignByFixedColumnCellCount > 0) {\n            var transparentColumnIndex = getTransparentColumnIndex(this._columnsController.getFixedColumns());\n            isEmptyCell = columns.length - alignByFixedColumnCellCount < transparentColumnIndex;\n          }\n        }\n      }\n      if (isEmptyCell) {\n        if (column.command && \"buttons\" !== column.type || \"group\" === options.rowType) {\n          $cell.html(\"&nbsp;\").addClass(column.cssClass);\n          return;\n        } else {\n          $cell.addClass(\"dx-hidden-cell\");\n        }\n      }\n    }\n    if (column.command !== COMMAND_TRANSPARENT) {\n      this.callBase.apply(this, arguments);\n    }\n  },\n  _getCellElementsCore: function _getCellElementsCore(rowIndex) {\n    var _this2 = this;\n    var cellElements = this.callBase.apply(this, arguments);\n    var isGroupRow = cellElements.parent().hasClass(GROUP_ROW_CLASS);\n    var headerRowIndex = \"columnHeadersView\" === this.name ? rowIndex : void 0;\n    if (this._fixedTableElement && cellElements) {\n      var fixedColumns = this.getFixedColumns(headerRowIndex);\n      var fixedCellElements = this._getRowElements(this._fixedTableElement).eq(rowIndex).children(\"td\");\n      each(fixedCellElements, function (columnIndex, cell) {\n        if (isGroupRow) {\n          if (cellElements[columnIndex] && \"hidden\" !== cell.style.visibility) {\n            cellElements[columnIndex] = cell;\n          }\n        } else {\n          var fixedColumn = fixedColumns[columnIndex];\n          if (fixedColumn) {\n            if (fixedColumn.command === COMMAND_TRANSPARENT) {\n              if (fixedCellElements.eq(columnIndex).hasClass(MASTER_DETAIL_CELL_CLASS)) {\n                cellElements[columnIndex] = cell || cellElements[columnIndex];\n              }\n            } else {\n              var fixedColumnIndex = _this2._columnsController.getVisibleIndexByColumn(fixedColumn, headerRowIndex);\n              cellElements[fixedColumnIndex] = cell || cellElements[fixedColumnIndex];\n            }\n          }\n        }\n      });\n    }\n    return cellElements;\n  },\n  getColumnWidths: function getColumnWidths() {\n    var fixedWidths;\n    var result = this.callBase();\n    var fixedColumns = this.getFixedColumns();\n    if (this._fixedTableElement && result.length) {\n      fixedWidths = this.callBase(this._fixedTableElement);\n    }\n    return normalizeColumnWidths(fixedColumns, result, fixedWidths);\n  },\n  getTableElement: function getTableElement() {\n    var tableElement = this._isFixedTableRendering ? this._fixedTableElement : this.callBase();\n    return tableElement;\n  },\n  setTableElement: function setTableElement(tableElement) {\n    if (this._isFixedTableRendering) {\n      this._fixedTableElement = tableElement.addClass(POINTER_EVENTS_NONE_CLASS);\n    } else {\n      this.callBase(tableElement);\n    }\n  },\n  getColumns: function getColumns(rowIndex, $tableElement) {\n    $tableElement = $tableElement || this.getTableElement();\n    if (this._isFixedTableRendering || $tableElement && $tableElement.closest(\"table\").parent(\".\" + this.addWidgetPrefix(CONTENT_FIXED_CLASS)).length) {\n      return this.getFixedColumns(rowIndex);\n    }\n    return this.callBase(rowIndex, $tableElement);\n  },\n  getRowIndex: function getRowIndex($row) {\n    var $fixedTable = this._fixedTableElement;\n    if ($fixedTable && $fixedTable.find($row).length) {\n      return this._getRowElements($fixedTable).index($row);\n    }\n    return this.callBase($row);\n  },\n  getTableElements: function getTableElements() {\n    var result = this.callBase.apply(this, arguments);\n    if (this._fixedTableElement) {\n      result = $([result.get(0), this._fixedTableElement.get(0)]);\n    }\n    return result;\n  },\n  getFixedColumns: function getFixedColumns(rowIndex) {\n    return this._columnsController.getFixedColumns(rowIndex);\n  },\n  getFixedColumnsOffset: function getFixedColumnsOffset() {\n    var offset = {\n      left: 0,\n      right: 0\n    };\n    var $transparentColumn;\n    if (this._fixedTableElement) {\n      $transparentColumn = this.getTransparentColumnElement();\n      var positionTransparentColumn = $transparentColumn.position();\n      offset = {\n        left: positionTransparentColumn.left,\n        right: getOuterWidth(this.element(), true) - (getOuterWidth($transparentColumn, true) + positionTransparentColumn.left)\n      };\n    }\n    return offset;\n  },\n  getTransparentColumnElement: function getTransparentColumnElement() {\n    return this._fixedTableElement && this._fixedTableElement.find(\".\" + POINTER_EVENTS_NONE_CLASS).first();\n  },\n  getFixedTableElement: function getFixedTableElement() {\n    return this._fixedTableElement;\n  },\n  isFixedColumns: function isFixedColumns() {\n    return this._isFixedColumns;\n  },\n  _resizeCore: function _resizeCore() {\n    this.callBase();\n    this.synchronizeRows();\n  },\n  setColumnWidths: function setColumnWidths(options) {\n    var columns;\n    var visibleColumns = this._columnsController.getVisibleColumns();\n    var widths = options.widths;\n    var isWidthsSynchronized = widths && widths.length && isDefined(visibleColumns[0].visibleWidth);\n    var optionNames = options.optionNames;\n    var isColumnWidthChanged = optionNames && optionNames.width;\n    var useVisibleColumns = false;\n    this.callBase.apply(this, arguments);\n    if (this._fixedTableElement) {\n      var hasAutoWidth = widths && widths.some(function (width) {\n        return \"auto\" === width;\n      });\n      useVisibleColumns = hasAutoWidth && (!isWidthsSynchronized || !this.isScrollbarVisible(true));\n      if (useVisibleColumns) {\n        columns = visibleColumns;\n      }\n      this.callBase(extend({}, options, {\n        $tableElement: this._fixedTableElement,\n        columns: columns,\n        fixed: true\n      }));\n    }\n    if (isWidthsSynchronized || isColumnWidthChanged && this.option(\"wordWrapEnabled\")) {\n      this.synchronizeRows();\n    }\n  },\n  _createColGroup: function _createColGroup(columns) {\n    if (this._isFixedTableRendering && !this.option(\"columnAutoWidth\")) {\n      var visibleColumns = this._columnsController.getVisibleColumns();\n      var useVisibleColumns = visibleColumns.filter(function (column) {\n        return !column.width;\n      }).length;\n      if (useVisibleColumns) {\n        columns = visibleColumns;\n      }\n    }\n    return this.callBase(columns);\n  },\n  _getClientHeight: function _getClientHeight(element) {\n    var boundingClientRectElement = element.getBoundingClientRect && getBoundingRect(element);\n    return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight;\n  },\n  synchronizeRows: function synchronizeRows() {\n    var rowHeights = [];\n    var fixedRowHeights = [];\n    var rowIndex;\n    var $rowElements;\n    var $fixedRowElements;\n    var $contentElement;\n    if (this._isFixedColumns && this._tableElement && this._fixedTableElement) {\n      var heightTable = this._getClientHeight(this._tableElement.get(0));\n      var heightFixedTable = this._getClientHeight(this._fixedTableElement.get(0));\n      $rowElements = this._getRowElements(this._tableElement);\n      $fixedRowElements = this._getRowElements(this._fixedTableElement);\n      $contentElement = this._findContentElement();\n      if (heightTable !== heightFixedTable) {\n        $contentElement && $contentElement.css(\"height\", heightTable);\n        $rowElements.css(\"height\", \"\");\n        $fixedRowElements.css(\"height\", \"\");\n        for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {\n          rowHeights.push(this._getClientHeight($rowElements.get(rowIndex)));\n          fixedRowHeights.push(this._getClientHeight($fixedRowElements.get(rowIndex)));\n        }\n        for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {\n          var rowHeight = rowHeights[rowIndex];\n          var fixedRowHeight = fixedRowHeights[rowIndex];\n          if (rowHeight > fixedRowHeight) {\n            $fixedRowElements.eq(rowIndex).css(\"height\", rowHeight);\n          } else if (rowHeight < fixedRowHeight) {\n            $rowElements.eq(rowIndex).css(\"height\", fixedRowHeight);\n          }\n        }\n        $contentElement && $contentElement.css(\"height\", \"\");\n      }\n    }\n  },\n  setScrollerSpacing: function setScrollerSpacing(width) {\n    var rtlEnabled = this.option(\"rtlEnabled\");\n    this.callBase(width);\n    this.element().children(\".\" + this.addWidgetPrefix(CONTENT_FIXED_CLASS)).css({\n      paddingLeft: rtlEnabled ? width : \"\",\n      paddingRight: !rtlEnabled ? width : \"\"\n    });\n  }\n};\nvar ColumnHeadersViewFixedColumnsExtender = extend({}, baseFixedColumns, {\n  _getRowVisibleColumns: function _getRowVisibleColumns(rowIndex) {\n    if (this._isFixedTableRendering) {\n      return this.getFixedColumns(rowIndex);\n    }\n    return this.callBase(rowIndex);\n  },\n  getContextMenuItems: function getContextMenuItems(options) {\n    var _this3 = this;\n    var column = options.column;\n    var columnFixingOptions = this.option(\"columnFixing\");\n    var items = this.callBase(options);\n    if (options.row && \"header\" === options.row.rowType) {\n      if (true === columnFixingOptions.enabled && column && column.allowFixing) {\n        var onItemClick = function onItemClick(params) {\n          switch (params.itemData.value) {\n            case \"none\":\n              _this3._columnsController.columnOption(column.index, \"fixed\", false);\n              break;\n            case \"left\":\n              _this3._columnsController.columnOption(column.index, {\n                fixed: true,\n                fixedPosition: \"left\"\n              });\n              break;\n            case \"right\":\n              _this3._columnsController.columnOption(column.index, {\n                fixed: true,\n                fixedPosition: \"right\"\n              });\n          }\n        };\n        items = items || [];\n        items.push({\n          text: columnFixingOptions.texts.fix,\n          beginGroup: true,\n          items: [{\n            text: columnFixingOptions.texts.leftPosition,\n            value: \"left\",\n            disabled: column.fixed && (!column.fixedPosition || \"left\" === column.fixedPosition),\n            onItemClick: onItemClick\n          }, {\n            text: columnFixingOptions.texts.rightPosition,\n            value: \"right\",\n            disabled: column.fixed && \"right\" === column.fixedPosition,\n            onItemClick: onItemClick\n          }]\n        }, {\n          text: columnFixingOptions.texts.unfix,\n          value: \"none\",\n          disabled: !column.fixed,\n          onItemClick: onItemClick\n        });\n      }\n    }\n    return items;\n  },\n  getFixedColumnElements: function getFixedColumnElements(rowIndex) {\n    if (isDefined(rowIndex)) {\n      return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).children();\n    }\n    var columnElements = this.getColumnElements();\n    var $transparentColumnElement = this.getTransparentColumnElement();\n    if (columnElements && $transparentColumnElement && $transparentColumnElement.length) {\n      var transparentColumnIndex = getTransparentColumnIndex(this.getFixedColumns());\n      columnElements.splice(transparentColumnIndex, $transparentColumnElement.get(0).colSpan, $transparentColumnElement.get(0));\n    }\n    return columnElements;\n  },\n  getColumnWidths: function getColumnWidths() {\n    var fixedWidths;\n    var result = this.callBase();\n    var $fixedColumnElements = this.getFixedColumnElements();\n    var fixedColumns = this.getFixedColumns();\n    if (this._fixedTableElement) {\n      if ($fixedColumnElements && $fixedColumnElements.length) {\n        fixedWidths = this._getWidths($fixedColumnElements);\n      } else {\n        fixedWidths = this.callBase(this._fixedTableElement);\n      }\n    }\n    return normalizeColumnWidths(fixedColumns, result, fixedWidths);\n  }\n});\nvar RowsViewFixedColumnsExtender = extend({}, baseFixedColumns, {\n  _detachHoverEvents: function _detachHoverEvents() {\n    this._fixedTableElement && eventsEngine.off(this._fixedTableElement, \"mouseover mouseout\", \".dx-data-row\");\n    this._tableElement && eventsEngine.off(this._tableElement, \"mouseover mouseout\", \".dx-data-row\");\n  },\n  _attachHoverEvents: function _attachHoverEvents() {\n    var that = this;\n    var attachHoverEvent = function attachHoverEvent($table) {\n      eventsEngine.on($table, \"mouseover mouseout\", \".dx-data-row\", that.createAction(function (args) {\n        var event = args.event;\n        var rowIndex = that.getRowIndex($(event.target).closest(\".dx-row\"));\n        var isHover = \"mouseover\" === event.type;\n        if (rowIndex >= 0) {\n          that._tableElement && that._getRowElements(that._tableElement).eq(rowIndex).toggleClass(HOVER_STATE_CLASS, isHover);\n          that._fixedTableElement && that._getRowElements(that._fixedTableElement).eq(rowIndex).toggleClass(HOVER_STATE_CLASS, isHover);\n        }\n      }));\n    };\n    if (that._fixedTableElement && that._tableElement) {\n      attachHoverEvent(that._fixedTableElement);\n      attachHoverEvent(that._tableElement);\n    }\n  },\n  _findContentElement: function _findContentElement() {\n    var that = this;\n    var $content;\n    var scrollTop;\n    var contentClass = that.addWidgetPrefix(CONTENT_CLASS);\n    var element = that.element();\n    var scrollDelay = browser.mozilla ? 60 : 0;\n    if (element && that._isFixedTableRendering) {\n      $content = element.children(\".\" + contentClass);\n      var scrollable = that.getScrollable();\n      if (!$content.length && scrollable) {\n        $content = $(\"<div>\").addClass(contentClass);\n        eventsEngine.on($content, \"scroll\", function (e) {\n          var target = e.target;\n          clearTimeout(that._fixedScrollTimeout);\n          that._fixedScrollTimeout = setTimeout(function () {\n            scrollTop = $(target).scrollTop();\n            scrollable.scrollTo({\n              y: scrollTop\n            });\n          }, scrollDelay);\n        });\n        eventsEngine.on($content, wheelEventName, function (e) {\n          var $nearestScrollable = $(e.target).closest(\".dx-scrollable\");\n          var shouldScroll = false;\n          if (scrollable && scrollable.$element().is($nearestScrollable)) {\n            shouldScroll = true;\n          } else {\n            var nearestScrollableInstance = $nearestScrollable.length && Scrollable.getInstance($nearestScrollable.get(0));\n            var nearestScrollableHasVerticalScrollbar = nearestScrollableInstance && nearestScrollableInstance.scrollHeight() - nearestScrollableInstance.clientHeight() > 0;\n            shouldScroll = nearestScrollableInstance && !nearestScrollableHasVerticalScrollbar;\n          }\n          if (shouldScroll) {\n            scrollTop = scrollable.scrollTop();\n            scrollable.scrollTo({\n              y: scrollTop - e.delta\n            });\n            if (scrollable.scrollTop() > 0 && scrollable.scrollTop() + scrollable.clientHeight() < scrollable.scrollHeight() + that.getScrollbarWidth()) {\n              return false;\n            }\n          }\n        });\n        $content.appendTo(element);\n      }\n      return $content;\n    }\n    return that.callBase();\n  },\n  _updateScrollable: function _updateScrollable() {\n    this.callBase();\n    var scrollable = this.getScrollable();\n    if (null !== scrollable && void 0 !== scrollable && scrollable._disposed) {\n      return;\n    }\n    var scrollTop = scrollable && scrollable.scrollOffset().top;\n    this._updateFixedTablePosition(scrollTop);\n  },\n  _renderContent: function _renderContent(contentElement, tableElement) {\n    if (this._isFixedTableRendering) {\n      return contentElement.empty().addClass(this.addWidgetPrefix(CONTENT_CLASS) + \" \" + this.addWidgetPrefix(CONTENT_FIXED_CLASS)).append(tableElement);\n    }\n    return this.callBase(contentElement, tableElement);\n  },\n  _getGroupCellOptions: function _getGroupCellOptions(options) {\n    if (this._isFixedTableRendering) {\n      return this.callBase(extend({}, options, {\n        columns: this._columnsController.getVisibleColumns()\n      }));\n    }\n    return this.callBase(options);\n  },\n  _renderGroupedCells: function _renderGroupedCells($row, options) {\n    return this.callBase($row, extend({}, options, {\n      columns: this._columnsController.getVisibleColumns()\n    }));\n  },\n  _renderGroupSummaryCells: function _renderGroupSummaryCells($row, options) {\n    if (this._isFixedTableRendering) {\n      this.callBase($row, extend({}, options, {\n        columns: this._columnsController.getVisibleColumns()\n      }));\n    } else {\n      this.callBase($row, options);\n    }\n  },\n  _hasAlignByColumnSummaryItems: function _hasAlignByColumnSummaryItems(columnIndex, options) {\n    var result = this.callBase.apply(this, arguments);\n    var column = options.columns[columnIndex];\n    if (options.isFixed) {\n      return column.fixed && (result || \"right\" === column.fixedPosition);\n    }\n    return result && (!this._isFixedColumns || !column.fixed);\n  },\n  _renderGroupSummaryCellsCore: function _renderGroupSummaryCellsCore($groupCell, options, groupCellColSpan, alignByColumnCellCount) {\n    var alignByFixedColumnCellCount;\n    if (this._isFixedTableRendering) {\n      options.isFixed = true;\n      alignByFixedColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);\n      options.isFixed = false;\n      var startColumnIndex = options.columns.length - alignByFixedColumnCellCount;\n      options = extend({}, options, {\n        columns: this.getFixedColumns()\n      });\n      var transparentColumnIndex = getTransparentColumnIndex(options.columns);\n      if (startColumnIndex < transparentColumnIndex) {\n        alignByFixedColumnCellCount -= options.columns[transparentColumnIndex].colspan - 1 || 0;\n        groupCellColSpan -= options.columns[transparentColumnIndex].colspan - 1 || 0;\n      } else if (alignByColumnCellCount > 0) {\n        $groupCell.css(\"visibility\", \"hidden\");\n      }\n      alignByColumnCellCount = alignByFixedColumnCellCount;\n    }\n    this.callBase($groupCell, options, groupCellColSpan, alignByColumnCellCount);\n  },\n  _getSummaryCellIndex: function _getSummaryCellIndex(columnIndex, columns) {\n    if (this._isFixedTableRendering) {\n      var transparentColumnIndex = getTransparentColumnIndex(columns);\n      if (columnIndex > transparentColumnIndex) {\n        columnIndex += columns[transparentColumnIndex].colspan - 1;\n      }\n      return columnIndex;\n    }\n    return this.callBase.apply(this, arguments);\n  },\n  _renderCore: function _renderCore(change) {\n    this._detachHoverEvents();\n    var deferred = this.callBase(change);\n    var isFixedColumns = this._isFixedColumns;\n    this.element().toggleClass(FIXED_COLUMNS_CLASS, isFixedColumns);\n    if (this.option(\"hoverStateEnabled\") && isFixedColumns) {\n      this._attachHoverEvents();\n    }\n    return deferred;\n  },\n  setRowsOpacity: function setRowsOpacity(columnIndex, value) {\n    this.callBase(columnIndex, value);\n    var $rows = this._getRowElements(this._fixedTableElement);\n    this._setRowsOpacityCore($rows, this.getFixedColumns(), columnIndex, value);\n  },\n  optionChanged: function optionChanged(args) {\n    this.callBase(args);\n    if (\"hoverStateEnabled\" === args.name && this._isFixedColumns) {\n      args.value ? this._attachHoverEvents() : this._detachHoverEvents();\n    }\n  },\n  getCellIndex: function getCellIndex($cell) {\n    var $fixedTable = this._fixedTableElement;\n    var cellIndex = 0;\n    if ($fixedTable && $cell.is(\"td\") && $cell.closest($fixedTable).length) {\n      var columns = this.getFixedColumns();\n      each(columns, function (index, column) {\n        if (index === $cell[0].cellIndex) {\n          return false;\n        }\n        if (column.colspan) {\n          cellIndex += column.colspan;\n          return;\n        }\n        cellIndex++;\n      });\n      return cellIndex;\n    }\n    return this.callBase.apply(this, arguments);\n  },\n  _updateFixedTablePosition: function _updateFixedTablePosition(scrollTop, needFocus) {\n    if (this._fixedTableElement && this._tableElement) {\n      var $focusedElement;\n      var editorFactory = this.getController(\"editorFactory\");\n      this._fixedTableElement.parent().scrollTop(scrollTop);\n      if (needFocus && editorFactory) {\n        $focusedElement = editorFactory.focus();\n        $focusedElement && editorFactory.focus($focusedElement);\n      }\n    }\n  },\n  setScrollerSpacing: function setScrollerSpacing(vWidth, hWidth) {\n    var styles = {\n      marginBottom: 0\n    };\n    var $fixedContent = this.element().children(\".\" + this.addWidgetPrefix(CONTENT_FIXED_CLASS));\n    if ($fixedContent.length && this._fixedTableElement) {\n      $fixedContent.css(styles);\n      this._fixedTableElement.css(styles);\n      styles[this.option(\"rtlEnabled\") ? \"marginLeft\" : \"marginRight\"] = vWidth;\n      styles.marginBottom = hWidth;\n      var useNativeScrolling = this._scrollable && this._scrollable.option(\"useNative\");\n      (useNativeScrolling ? $fixedContent : this._fixedTableElement).css(styles);\n    }\n  },\n  _getElasticScrollTop: function _getElasticScrollTop(e) {\n    var elasticScrollTop = 0;\n    if (e.scrollOffset.top < 0) {\n      elasticScrollTop = -e.scrollOffset.top;\n    } else if (e.reachedBottom) {\n      var $scrollableContent = $(e.component.content());\n      var $scrollableContainer = $(e.component.container());\n      var maxScrollTop = Math.max($scrollableContent.get(0).clientHeight - $scrollableContainer.get(0).clientHeight, 0);\n      elasticScrollTop = maxScrollTop - e.scrollOffset.top;\n    }\n    return Math.floor(elasticScrollTop);\n  },\n  _applyElasticScrolling: function _applyElasticScrolling(e) {\n    if (this._fixedTableElement) {\n      var elasticScrollTop = this._getElasticScrollTop(e);\n      if (0 !== Math.ceil(elasticScrollTop)) {\n        move(this._fixedTableElement, {\n          top: elasticScrollTop\n        });\n      } else {\n        this._fixedTableElement.css(\"transform\", \"\");\n      }\n    }\n  },\n  _handleScroll: function _handleScroll(e) {\n    this._updateFixedTablePosition(e.scrollOffset.top, true);\n    this._applyElasticScrolling(e);\n    this.callBase(e);\n  },\n  _updateContentPosition: function _updateContentPosition(isRender) {\n    this.callBase.apply(this, arguments);\n    if (!isRender) {\n      this._updateFixedTablePosition(this._scrollTop);\n    }\n  },\n  _afterRowPrepared: function _afterRowPrepared(e) {\n    if (this._isFixedTableRendering) {\n      return;\n    }\n    this.callBase(e);\n  },\n  _scrollToElement: function _scrollToElement($element) {\n    this.callBase($element, this.getFixedColumnsOffset());\n  },\n  dispose: function dispose() {\n    this.callBase.apply(this, arguments);\n    clearTimeout(this._fixedScrollTimeout);\n  }\n});\nvar FooterViewFixedColumnsExtender = baseFixedColumns;\nexport var columnFixingModule = {\n  defaultOptions: function defaultOptions() {\n    return {\n      columnFixing: {\n        enabled: false,\n        texts: {\n          fix: messageLocalization.format(\"dxDataGrid-columnFixingFix\"),\n          unfix: messageLocalization.format(\"dxDataGrid-columnFixingUnfix\"),\n          leftPosition: messageLocalization.format(\"dxDataGrid-columnFixingLeftPosition\"),\n          rightPosition: messageLocalization.format(\"dxDataGrid-columnFixingRightPosition\")\n        }\n      }\n    };\n  },\n  extenders: {\n    views: {\n      columnHeadersView: ColumnHeadersViewFixedColumnsExtender,\n      rowsView: RowsViewFixedColumnsExtender,\n      footerView: FooterViewFixedColumnsExtender\n    },\n    controllers: {\n      draggingHeader: {\n        _generatePointsByColumns: function _generatePointsByColumns(options) {\n          var visibleColumns = options.columns;\n          var targetDraggingPanel = options.targetDraggingPanel;\n          if (targetDraggingPanel && \"headers\" === targetDraggingPanel.getName() && targetDraggingPanel.isFixedColumns()) {\n            if (options.sourceColumn.fixed) {\n              if (!options.rowIndex) {\n                options.columnElements = targetDraggingPanel.getFixedColumnElements(0);\n              }\n              options.columns = targetDraggingPanel.getFixedColumns(options.rowIndex);\n              var pointsByColumns = this.callBase(options);\n              !function (columns, fixedColumns, pointsByColumns) {\n                var transparentColumnIndex = getTransparentColumnIndex(fixedColumns);\n                var correctIndex = columns.length - fixedColumns.length;\n                each(pointsByColumns, function (_, point) {\n                  if (point.index > transparentColumnIndex) {\n                    point.columnIndex += correctIndex;\n                    point.index += correctIndex;\n                  }\n                });\n                return pointsByColumns;\n              }(visibleColumns, options.columns, pointsByColumns);\n              return pointsByColumns;\n            }\n          }\n          return this.callBase(options);\n        },\n        _pointCreated: function _pointCreated(point, columns, location, sourceColumn) {\n          var result = this.callBase.apply(this, arguments);\n          var targetColumn = columns[point.columnIndex];\n          var $transparentColumn = this._columnHeadersView.getTransparentColumnElement();\n          if (!result && \"headers\" === location && $transparentColumn && $transparentColumn.length) {\n            var boundingRect = getBoundingRect($transparentColumn.get(0));\n            if (sourceColumn && sourceColumn.fixed) {\n              return \"right\" === sourceColumn.fixedPosition ? point.x < boundingRect.right : point.x > boundingRect.left;\n            } else {\n              if (targetColumn && targetColumn.fixed && \"right\" !== targetColumn.fixedPosition) {\n                return true;\n              }\n              return point.x < boundingRect.left || point.x > boundingRect.right;\n            }\n          }\n          return result;\n        }\n      },\n      columnsResizer: {\n        _generatePointsByColumns: function _generatePointsByColumns() {\n          var that = this;\n          var columnsController = that._columnsController;\n          var columns = columnsController && that._columnsController.getVisibleColumns();\n          var fixedColumns = columnsController && that._columnsController.getFixedColumns();\n          var transparentColumnIndex = getTransparentColumnIndex(fixedColumns);\n          var correctIndex = columns.length - fixedColumns.length;\n          var cells = that._columnHeadersView.getFixedColumnElements();\n          that.callBase();\n          if (cells && cells.length > 0) {\n            that._pointsByFixedColumns = gridCoreUtils.getPointsByColumns(cells, function (point) {\n              if (point.index > transparentColumnIndex) {\n                point.columnIndex += correctIndex;\n                point.index += correctIndex;\n              }\n              return that._pointCreated(point, columns.length, columns);\n            });\n          }\n        },\n        _getTargetPoint: function _getTargetPoint(pointsByColumns, currentX, deltaX) {\n          var $transparentColumn = this._columnHeadersView.getTransparentColumnElement();\n          if ($transparentColumn && $transparentColumn.length) {\n            var boundingRect = getBoundingRect($transparentColumn.get(0));\n            if (currentX <= boundingRect.left || currentX >= boundingRect.right) {\n              return this.callBase(this._pointsByFixedColumns, currentX, deltaX);\n            }\n          }\n          return this.callBase(pointsByColumns, currentX, deltaX);\n        }\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}