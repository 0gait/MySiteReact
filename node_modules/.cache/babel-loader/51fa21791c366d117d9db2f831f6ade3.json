{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\MySiteReact\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n/**\r\n * DevExtreme (esm/data/array_utils.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { isDefined, isEmptyObject, isObject, isPlainObject } from \"../core/utils/type\";\nimport config from \"../core/config\";\nimport Guid from \"../core/guid\";\nimport { extend } from \"../core/utils/extend\";\nimport { errors } from \"./errors\";\nimport { deepExtendArraySafe } from \"../core/utils/object\";\nimport { compileGetter } from \"../core/utils/data\";\nimport { keysEqual, rejectedPromise, trivialPromise } from \"./utils\";\nfunction hasKey(target, keyOrKeys) {\n  var key;\n  var keys = \"string\" === typeof keyOrKeys ? keyOrKeys.split() : keyOrKeys.slice();\n  while (keys.length) {\n    key = keys.shift();\n    if (key in target) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction findItems(keyInfo, items, key, groupCount) {\n  var childItems;\n  var result;\n  if (groupCount) {\n    for (var i = 0; i < items.length; i++) {\n      childItems = items[i].items || items[i].collapsedItems || [];\n      result = findItems(keyInfo, childItems || [], key, groupCount - 1);\n      if (result) {\n        return result;\n      }\n    }\n  } else if (indexByKey(keyInfo, items, key) >= 0) {\n    return items;\n  }\n}\nfunction getItems(keyInfo, items, key, groupCount) {\n  if (groupCount) {\n    return findItems(keyInfo, items, key, groupCount) || [];\n  }\n  return items;\n}\nfunction generateDataByKeyMap(keyInfo, array) {\n  if (keyInfo.key() && (!array._dataByKeyMap || array._dataByKeyMapLength !== array.length)) {\n    var dataByKeyMap = {};\n    var arrayLength = array.length;\n    for (var i = 0; i < arrayLength; i++) {\n      dataByKeyMap[JSON.stringify(keyInfo.keyOf(array[i]))] = array[i];\n    }\n    array._dataByKeyMap = dataByKeyMap;\n    array._dataByKeyMapLength = arrayLength;\n  }\n}\nfunction getCacheValue(array, key) {\n  if (array._dataByKeyMap) {\n    return array._dataByKeyMap[JSON.stringify(key)];\n  }\n}\nfunction getHasKeyCacheValue(array, key) {\n  if (array._dataByKeyMap) {\n    return array._dataByKeyMap[JSON.stringify(key)];\n  }\n  return true;\n}\nfunction setDataByKeyMapValue(array, key, data) {\n  if (array._dataByKeyMap) {\n    array._dataByKeyMap[JSON.stringify(key)] = data;\n    array._dataByKeyMapLength += data ? 1 : -1;\n  }\n}\nfunction cloneInstanceWithChangedPaths(instance, changes, clonedInstances) {\n  clonedInstances = clonedInstances || new WeakMap();\n  var result = instance ? Object.create(Object.getPrototypeOf(instance)) : {};\n  if (instance) {\n    clonedInstances.set(instance, result);\n  }\n  var instanceWithoutPrototype = _extends({}, instance);\n  deepExtendArraySafe(result, instanceWithoutPrototype, true, true);\n  for (var name in instanceWithoutPrototype) {\n    var value = instanceWithoutPrototype[name];\n    var change = null === changes || void 0 === changes ? void 0 : changes[name];\n    if (isObject(value) && !isPlainObject(value) && isObject(change) && !clonedInstances.has(value)) {\n      result[name] = cloneInstanceWithChangedPaths(value, change, clonedInstances);\n    }\n  }\n  for (var _name in result) {\n    var prop = result[_name];\n    if (isObject(prop) && clonedInstances.has(prop)) {\n      result[_name] = clonedInstances.get(prop);\n    }\n  }\n  return result;\n}\nfunction createObjectWithChanges(target, changes) {\n  var result = cloneInstanceWithChangedPaths(target, changes);\n  return deepExtendArraySafe(result, changes, true, true);\n}\nfunction applyBatch(_ref) {\n  var keyInfo = _ref.keyInfo,\n    data = _ref.data,\n    changes = _ref.changes,\n    groupCount = _ref.groupCount,\n    useInsertIndex = _ref.useInsertIndex,\n    immutable = _ref.immutable,\n    disableCache = _ref.disableCache,\n    logError = _ref.logError,\n    skipCopying = _ref.skipCopying;\n  var resultItems = true === immutable ? _toConsumableArray(data) : data;\n  changes.forEach(function (item) {\n    var items = \"insert\" === item.type ? resultItems : getItems(keyInfo, resultItems, item.key, groupCount);\n    !disableCache && generateDataByKeyMap(keyInfo, items);\n    switch (item.type) {\n      case \"update\":\n        update(keyInfo, items, item.key, item.data, true, immutable, logError);\n        break;\n      case \"insert\":\n        insert(keyInfo, items, item.data, useInsertIndex && isDefined(item.index) ? item.index : -1, true, logError, skipCopying);\n        break;\n      case \"remove\":\n        remove(keyInfo, items, item.key, true, logError);\n    }\n  });\n  return resultItems;\n}\nfunction getErrorResult(isBatch, logError, errorCode) {\n  return !isBatch ? rejectedPromise(errors.Error(errorCode)) : logError && errors.log(errorCode);\n}\nfunction applyChanges(data, changes) {\n  var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n  var _options$keyExpr = options.keyExpr,\n    keyExpr = _options$keyExpr === void 0 ? \"id\" : _options$keyExpr,\n    _options$immutable = options.immutable,\n    immutable = _options$immutable === void 0 ? true : _options$immutable;\n  var keyGetter = compileGetter(keyExpr);\n  var keyInfo = {\n    key: function key() {\n      return keyExpr;\n    },\n    keyOf: function keyOf(obj) {\n      return keyGetter(obj);\n    }\n  };\n  return applyBatch({\n    keyInfo: keyInfo,\n    data: data,\n    changes: changes,\n    immutable: immutable,\n    disableCache: true,\n    logError: true\n  });\n}\nfunction update(keyInfo, array, key, data, isBatch, immutable, logError) {\n  var target;\n  var keyExpr = keyInfo.key();\n  if (keyExpr) {\n    if (hasKey(data, keyExpr) && !keysEqual(keyExpr, key, keyInfo.keyOf(data))) {\n      return getErrorResult(isBatch, logError, \"E4017\");\n    }\n    target = getCacheValue(array, key);\n    if (!target) {\n      var index = indexByKey(keyInfo, array, key);\n      if (index < 0) {\n        return getErrorResult(isBatch, logError, \"E4009\");\n      }\n      target = array[index];\n      if (true === immutable && isDefined(target)) {\n        var newTarget = createObjectWithChanges(target, data);\n        array[index] = newTarget;\n        return !isBatch && trivialPromise(newTarget, key);\n      }\n    }\n  } else {\n    target = key;\n  }\n  deepExtendArraySafe(target, data, true);\n  if (!isBatch) {\n    if (config().useLegacyStoreResult) {\n      return trivialPromise(key, data);\n    } else {\n      return trivialPromise(target, key);\n    }\n  }\n}\nfunction insert(keyInfo, array, data, index, isBatch, logError, skipCopying) {\n  var keyValue;\n  var keyExpr = keyInfo.key();\n  var obj = isPlainObject(data) && !skipCopying ? extend({}, data) : data;\n  if (keyExpr) {\n    keyValue = keyInfo.keyOf(obj);\n    if (void 0 === keyValue || \"object\" === typeof keyValue && isEmptyObject(keyValue)) {\n      if (Array.isArray(keyExpr)) {\n        throw errors.Error(\"E4007\");\n      }\n      keyValue = obj[keyExpr] = String(new Guid());\n    } else if (void 0 !== array[indexByKey(keyInfo, array, keyValue)]) {\n      return getErrorResult(isBatch, logError, \"E4008\");\n    }\n  } else {\n    keyValue = obj;\n  }\n  if (index >= 0) {\n    array.splice(index, 0, obj);\n  } else {\n    array.push(obj);\n  }\n  setDataByKeyMapValue(array, keyValue, obj);\n  if (!isBatch) {\n    return trivialPromise(config().useLegacyStoreResult ? data : obj, keyValue);\n  }\n}\nfunction remove(keyInfo, array, key, isBatch, logError) {\n  var index = indexByKey(keyInfo, array, key);\n  if (index > -1) {\n    array.splice(index, 1);\n    setDataByKeyMapValue(array, key, null);\n  }\n  if (!isBatch) {\n    return trivialPromise(key);\n  } else if (index < 0) {\n    return getErrorResult(isBatch, logError, \"E4009\");\n  }\n}\nfunction indexByKey(keyInfo, array, key) {\n  var keyExpr = keyInfo.key();\n  if (!getHasKeyCacheValue(array, key)) {\n    return -1;\n  }\n  for (var i = 0, arrayLength = array.length; i < arrayLength; i++) {\n    if (keysEqual(keyExpr, keyInfo.keyOf(array[i]), key)) {\n      return i;\n    }\n  }\n  return -1;\n}\nexport { applyBatch, createObjectWithChanges, update, insert, remove, indexByKey, applyChanges };","map":null,"metadata":{},"sourceType":"module"}