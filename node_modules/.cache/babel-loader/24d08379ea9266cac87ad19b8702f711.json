{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n/**\r\n * DevExtreme (esm/ui/scheduler/recurrence.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport errors from \"../../core/errors\";\nimport { each } from \"../../core/utils/iterator\";\nimport { RRule, RRuleSet } from \"rrule\";\nimport dateUtils from \"../../core/utils/date\";\nimport timeZoneUtils from \"./utils.timeZone\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"];\nvar freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"];\nvar days = {\n  SU: 0,\n  MO: 1,\n  TU: 2,\n  WE: 3,\n  TH: 4,\n  FR: 5,\n  SA: 6\n};\nvar loggedWarnings = [];\nvar MS_IN_HOUR = 36e5;\nvar MS_IN_DAY = 24 * MS_IN_HOUR;\nvar recurrence = null;\nexport function getRecurrenceProcessor() {\n  if (!recurrence) {\n    recurrence = new RecurrenceProcessor();\n  }\n  return recurrence;\n}\nvar RecurrenceProcessor = /*#__PURE__*/function () {\n  function RecurrenceProcessor() {\n    _classCallCheck(this, RecurrenceProcessor);\n    this.rRule = null;\n    this.rRuleSet = null;\n    this.validator = new RecurrenceValidator();\n  }\n  _createClass(RecurrenceProcessor, [{\n    key: \"generateDates\",\n    value: function generateDates(options) {\n      var _this = this;\n      var recurrenceRule = this.evalRecurrenceRule(options.rule);\n      var rule = recurrenceRule.rule;\n      if (!recurrenceRule.isValid || !rule.freq) {\n        return [];\n      }\n      var rruleIntervalParams = this._createRruleIntervalParams(options);\n      this._initializeRRule(options, rruleIntervalParams.startIntervalDate, rule.until);\n      return this.rRuleSet.between(rruleIntervalParams.minViewDate, rruleIntervalParams.maxViewDate, true).filter(function (date) {\n        return date.getTime() + rruleIntervalParams.appointmentDuration >= rruleIntervalParams.minViewTime;\n      }).map(function (date) {\n        return _this._convertRruleResult(rruleIntervalParams, options, date);\n      });\n    }\n  }, {\n    key: \"_createRruleIntervalParams\",\n    value: function _createRruleIntervalParams(options) {\n      var start = options.start,\n        min = options.min,\n        max = options.max,\n        appointmentTimezoneOffset = options.appointmentTimezoneOffset;\n      var clientOffsets_startDate = timeZoneUtils.getClientTimezoneOffset(start),\n        clientOffsets_minViewDate = timeZoneUtils.getClientTimezoneOffset(min),\n        clientOffsets_maxViewDate = timeZoneUtils.getClientTimezoneOffset(max);\n      var duration = options.end ? options.end.getTime() - options.start.getTime() : 0;\n      var startIntervalDate = timeZoneUtils.setOffsetsToDate(options.start, [-clientOffsets_startDate, appointmentTimezoneOffset]);\n      var minViewTime = options.min.getTime() - clientOffsets_minViewDate + appointmentTimezoneOffset;\n      var minViewDate = new Date(minViewTime - duration);\n      var maxViewDate = timeZoneUtils.setOffsetsToDate(options.max, [-clientOffsets_maxViewDate, appointmentTimezoneOffset]);\n      var startDateDSTDifferenceMs = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(options.start, startIntervalDate);\n      var switchToSummerTime = startDateDSTDifferenceMs < 0;\n      return {\n        startIntervalDate: startIntervalDate,\n        minViewTime: minViewTime,\n        minViewDate: minViewDate,\n        maxViewDate: maxViewDate,\n        startIntervalDateDSTShift: switchToSummerTime ? 0 : startDateDSTDifferenceMs,\n        appointmentDuration: duration\n      };\n    }\n  }, {\n    key: \"_convertRruleResult\",\n    value: function _convertRruleResult(rruleIntervalParams, options, rruleDate) {\n      var localTimezoneOffset = timeZoneUtils.getClientTimezoneOffset(rruleDate);\n      var additionalWorkaroundOffsetForRrule = localTimezoneOffset / MS_IN_HOUR <= -13 ? -MS_IN_DAY : 0;\n      var convertedBackDate = timeZoneUtils.setOffsetsToDate(rruleDate, [localTimezoneOffset, additionalWorkaroundOffsetForRrule, -options.appointmentTimezoneOffset, rruleIntervalParams.startIntervalDateDSTShift]);\n      var convertedDateDSTShift = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(convertedBackDate, rruleDate);\n      var switchToSummerTime = convertedDateDSTShift < 0;\n      var resultDate = timeZoneUtils.setOffsetsToDate(convertedBackDate, [convertedDateDSTShift]);\n      var resultDateDSTShift = timeZoneUtils.getDiffBetweenClientTimezoneOffsets(resultDate, convertedBackDate);\n      if (resultDateDSTShift && switchToSummerTime) {\n        return new Date(resultDate.getTime() + resultDateDSTShift);\n      }\n      return resultDate;\n    }\n  }, {\n    key: \"hasRecurrence\",\n    value: function hasRecurrence(options) {\n      return !!this.generateDates(options).length;\n    }\n  }, {\n    key: \"evalRecurrenceRule\",\n    value: function evalRecurrenceRule(rule) {\n      var result = {\n        rule: {},\n        isValid: false\n      };\n      if (rule) {\n        result.rule = this._parseRecurrenceRule(rule);\n        result.isValid = this.validator.validateRRule(result.rule, rule);\n      }\n      return result;\n    }\n  }, {\n    key: \"isValidRecurrenceRule\",\n    value: function isValidRecurrenceRule(rule) {\n      return this.evalRecurrenceRule(rule).isValid;\n    }\n  }, {\n    key: \"daysFromByDayRule\",\n    value: function daysFromByDayRule(rule) {\n      var result = [];\n      if (rule.byday) {\n        if (Array.isArray(rule.byday)) {\n          result = rule.byday;\n        } else {\n          result = rule.byday.split(\",\");\n        }\n      }\n      return result.map(function (item) {\n        var match = item.match(/[A-Za-z]+/);\n        return !!match && match[0];\n      }).filter(function (item) {\n        return !!item;\n      });\n    }\n  }, {\n    key: \"getAsciiStringByDate\",\n    value: function getAsciiStringByDate(date) {\n      var currentOffset = date.getTimezoneOffset() * toMs(\"minute\");\n      var offsetDate = new Date(date.getTime() + currentOffset);\n      return offsetDate.getFullYear() + (\"0\" + (offsetDate.getMonth() + 1)).slice(-2) + (\"0\" + offsetDate.getDate()).slice(-2) + \"T\" + (\"0\" + offsetDate.getHours()).slice(-2) + (\"0\" + offsetDate.getMinutes()).slice(-2) + (\"0\" + offsetDate.getSeconds()).slice(-2) + \"Z\";\n    }\n  }, {\n    key: \"getRecurrenceString\",\n    value: function getRecurrenceString(object) {\n      if (!object || !object.freq) {\n        return;\n      }\n      var result = \"\";\n      for (var field in object) {\n        var value = object[field];\n        if (\"interval\" === field && value < 2) {\n          continue;\n        }\n        if (\"until\" === field) {\n          value = this.getAsciiStringByDate(value);\n        }\n        result += field + \"=\" + value + \";\";\n      }\n      result = result.substring(0, result.length - 1);\n      return result.toUpperCase();\n    }\n  }, {\n    key: \"_parseExceptionToRawArray\",\n    value: function _parseExceptionToRawArray(value) {\n      return value.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/);\n    }\n  }, {\n    key: \"getDateByAsciiString\",\n    value: function getDateByAsciiString(exceptionText) {\n      if (\"string\" !== typeof exceptionText) {\n        return exceptionText;\n      }\n      var result = this._parseExceptionToRawArray(exceptionText);\n      if (!result) {\n        return null;\n      }\n      var _this$_createDateTupl = this._createDateTuple(result),\n        _this$_createDateTupl2 = _slicedToArray(_this$_createDateTupl, 7),\n        year = _this$_createDateTupl2[0],\n        month = _this$_createDateTupl2[1],\n        date = _this$_createDateTupl2[2],\n        hours = _this$_createDateTupl2[3],\n        minutes = _this$_createDateTupl2[4],\n        seconds = _this$_createDateTupl2[5],\n        isUtc = _this$_createDateTupl2[6];\n      if (isUtc) {\n        return new Date(Date.UTC(year, month, date, hours, minutes, seconds));\n      }\n      return new Date(year, month, date, hours, minutes, seconds);\n    }\n  }, {\n    key: \"_dispose\",\n    value: function _dispose() {\n      if (this.rRuleSet) {\n        delete this.rRuleSet;\n        this.rRuleSet = null;\n      }\n      if (this.rRule) {\n        delete this.rRule;\n        this.rRule = null;\n      }\n    }\n  }, {\n    key: \"_getTimeZoneOffset\",\n    value: function _getTimeZoneOffset() {\n      return new Date().getTimezoneOffset();\n    }\n  }, {\n    key: \"_initializeRRule\",\n    value: function _initializeRRule(options, startDateUtc, until) {\n      var _this2 = this;\n      var ruleOptions = RRule.parseString(options.rule);\n      var firstDayOfWeek = options.firstDayOfWeek;\n      ruleOptions.dtstart = startDateUtc;\n      if (!ruleOptions.wkst && firstDayOfWeek) {\n        ruleOptions.wkst = [6, 0, 1, 2, 3, 4, 5][firstDayOfWeek];\n      }\n      if (until) {\n        ruleOptions.until = timeZoneUtils.setOffsetsToDate(until, [-timeZoneUtils.getClientTimezoneOffset(until), options.appointmentTimezoneOffset]);\n      }\n      this._createRRule(ruleOptions);\n      if (options.exception) {\n        var exceptionStrings = options.exception;\n        var exceptionDates = exceptionStrings.split(\",\").map(function (rule) {\n          return _this2.getDateByAsciiString(rule);\n        });\n        exceptionDates.forEach(function (date) {\n          if (options.getPostProcessedException) {\n            date = options.getPostProcessedException(date);\n          }\n          var utcDate = timeZoneUtils.setOffsetsToDate(date, [-timeZoneUtils.getClientTimezoneOffset(date), options.appointmentTimezoneOffset]);\n          _this2.rRuleSet.exdate(utcDate);\n        });\n      }\n    }\n  }, {\n    key: \"_createRRule\",\n    value: function _createRRule(ruleOptions) {\n      this._dispose();\n      this.rRuleSet = new RRuleSet();\n      this.rRule = new RRule(ruleOptions);\n      this.rRuleSet.rrule(this.rRule);\n    }\n  }, {\n    key: \"_parseRecurrenceRule\",\n    value: function _parseRecurrenceRule(recurrence) {\n      var ruleObject = {};\n      var ruleParts = recurrence.split(\";\");\n      for (var i = 0, len = ruleParts.length; i < len; i++) {\n        var rule = ruleParts[i].split(\"=\");\n        var ruleName = rule[0].toLowerCase();\n        var ruleValue = rule[1];\n        ruleObject[ruleName] = ruleValue;\n      }\n      var count = parseInt(ruleObject.count);\n      if (!isNaN(count)) {\n        ruleObject.count = count;\n      }\n      if (ruleObject.interval) {\n        var interval = parseInt(ruleObject.interval);\n        if (!isNaN(interval)) {\n          ruleObject.interval = interval;\n        }\n      } else {\n        ruleObject.interval = 1;\n      }\n      if (ruleObject.freq && ruleObject.until) {\n        ruleObject.until = this.getDateByAsciiString(ruleObject.until);\n      }\n      return ruleObject;\n    }\n  }, {\n    key: \"_createDateTuple\",\n    value: function _createDateTuple(parseResult) {\n      var isUtc = void 0 !== parseResult[8];\n      parseResult.shift();\n      if (void 0 === parseResult[3]) {\n        parseResult.splice(3);\n      } else {\n        parseResult.splice(3, 1);\n        parseResult.splice(6);\n      }\n      parseResult[1]--;\n      parseResult.unshift(null);\n      return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc];\n    }\n  }]);\n  return RecurrenceProcessor;\n}();\nvar RecurrenceValidator = /*#__PURE__*/function () {\n  function RecurrenceValidator() {\n    _classCallCheck(this, RecurrenceValidator);\n  }\n  _createClass(RecurrenceValidator, [{\n    key: \"validateRRule\",\n    value: function validateRRule(rule, recurrence) {\n      if (this._brokenRuleNameExists(rule) || !freqNames.includes(rule.freq) || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {\n        this._logBrokenRule(recurrence);\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"_wrongUntilRule\",\n    value: function _wrongUntilRule(rule) {\n      var wrongUntil = false;\n      var until = rule.until;\n      if (void 0 !== until && !(until instanceof Date)) {\n        wrongUntil = true;\n      }\n      return wrongUntil;\n    }\n  }, {\n    key: \"_wrongCountRule\",\n    value: function _wrongCountRule(rule) {\n      var wrongCount = false;\n      var count = rule.count;\n      if (count && \"string\" === typeof count) {\n        wrongCount = true;\n      }\n      return wrongCount;\n    }\n  }, {\n    key: \"_wrongByMonthDayRule\",\n    value: function _wrongByMonthDayRule(rule) {\n      var wrongByMonthDay = false;\n      var byMonthDay = rule.bymonthday;\n      if (byMonthDay && isNaN(parseInt(byMonthDay))) {\n        wrongByMonthDay = true;\n      }\n      return wrongByMonthDay;\n    }\n  }, {\n    key: \"_wrongByMonth\",\n    value: function _wrongByMonth(rule) {\n      var wrongByMonth = false;\n      var byMonth = rule.bymonth;\n      if (byMonth && isNaN(parseInt(byMonth))) {\n        wrongByMonth = true;\n      }\n      return wrongByMonth;\n    }\n  }, {\n    key: \"_wrongIntervalRule\",\n    value: function _wrongIntervalRule(rule) {\n      var wrongInterval = false;\n      var interval = rule.interval;\n      if (interval && \"string\" === typeof interval) {\n        wrongInterval = true;\n      }\n      return wrongInterval;\n    }\n  }, {\n    key: \"_wrongDayOfWeek\",\n    value: function _wrongDayOfWeek(rule) {\n      var byDay = rule.byday;\n      var daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);\n      var brokenDaysExist = false;\n      if (\"\" === byDay) {\n        brokenDaysExist = true;\n      }\n      each(daysByRule, function (_, day) {\n        if (!Object.prototype.hasOwnProperty.call(days, day)) {\n          brokenDaysExist = true;\n          return false;\n        }\n      });\n      return brokenDaysExist;\n    }\n  }, {\n    key: \"_brokenRuleNameExists\",\n    value: function _brokenRuleNameExists(rule) {\n      var brokenRuleExists = false;\n      each(rule, function (ruleName) {\n        if (!ruleNames.includes(ruleName)) {\n          brokenRuleExists = true;\n          return false;\n        }\n      });\n      return brokenRuleExists;\n    }\n  }, {\n    key: \"_logBrokenRule\",\n    value: function _logBrokenRule(recurrence) {\n      if (!loggedWarnings.includes(recurrence)) {\n        errors.log(\"W0006\", recurrence);\n        loggedWarnings.push(recurrence);\n      }\n    }\n  }]);\n  return RecurrenceValidator;\n}();","map":null,"metadata":{},"sourceType":"module"}