{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/validation_message.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getOuterWidth } from \"../core/utils/size\";\nimport $ from \"../core/renderer\";\nimport registerComponent from \"../core/component_registrator\";\nimport Overlay from \"./overlay/ui.overlay\";\nimport { extend } from \"../core/utils/extend\";\nimport { encodeHtml } from \"../core/utils/string\";\nimport { getDefaultAlignment } from \"../core/utils/position\";\nvar INVALID_MESSAGE = \"dx-invalid-message\";\nvar INVALID_MESSAGE_AUTO = \"dx-invalid-message-auto\";\nvar INVALID_MESSAGE_ALWAYS = \"dx-invalid-message-always\";\nvar INVALID_MESSAGE_CONTENT = \"dx-invalid-message-content\";\nvar VALIDATION_MESSAGE_MIN_WIDTH = 100;\nvar ValidationMessage = Overlay.inherit({\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      integrationOptions: {},\n      templatesRenderAsynchronously: false,\n      shading: false,\n      width: \"auto\",\n      height: \"auto\",\n      hideOnOutsideClick: false,\n      animation: null,\n      visible: true,\n      propagateOutsideClick: true,\n      _checkParentVisibility: false,\n      rtlEnabled: false,\n      contentTemplate: this._renderInnerHtml,\n      maxWidth: \"100%\",\n      container: this.$element(),\n      target: void 0,\n      mode: \"auto\",\n      validationErrors: void 0,\n      positionSide: \"top\",\n      boundary: void 0,\n      offset: {\n        h: 0,\n        v: 0\n      },\n      contentId: void 0\n    });\n  },\n  _init: function _init() {\n    this.callBase();\n    this.updateMaxWidth();\n    this._updatePosition();\n  },\n  _initMarkup: function _initMarkup() {\n    this.callBase();\n    this._ensureMessageNotEmpty();\n    this._updatePositionByTarget();\n    this._toggleModeClass();\n    this._updateContentId();\n  },\n  _updatePositionByTarget: function _updatePositionByTarget() {\n    var _this$option2 = this.option(),\n      target = _this$option2.target;\n    this.option(\"position.of\", target);\n  },\n  _ensureMessageNotEmpty: function _ensureMessageNotEmpty() {\n    this._textMarkup = this._getTextMarkup();\n    var shouldShowMessage = this.option(\"visible\") && this._textMarkup;\n    this._toggleVisibilityClasses(shouldShowMessage);\n  },\n  _toggleVisibilityClasses: function _toggleVisibilityClasses(visible) {\n    if (visible) {\n      this.$element().addClass(INVALID_MESSAGE);\n      this.$wrapper().addClass(INVALID_MESSAGE);\n    } else {\n      this.$element().removeClass(INVALID_MESSAGE);\n      this.$wrapper().removeClass(INVALID_MESSAGE);\n    }\n  },\n  _updateContentId: function _updateContentId() {\n    var _this$option3 = this.option(),\n      container = _this$option3.container,\n      contentId = _this$option3.contentId;\n    var id = null !== contentId && void 0 !== contentId ? contentId : $(container).attr(\"aria-describedby\");\n    this.$content().addClass(INVALID_MESSAGE_CONTENT).attr(\"id\", id);\n  },\n  _renderInnerHtml: function _renderInnerHtml(element) {\n    var $element = element && $(element);\n    null === $element || void 0 === $element ? void 0 : $element.html(this._textMarkup);\n  },\n  _getTextMarkup: function _getTextMarkup() {\n    var _this$option;\n    var validationErrors = null !== (_this$option = this.option(\"validationErrors\")) && void 0 !== _this$option ? _this$option : [];\n    var validationErrorMessage = \"\";\n    validationErrors.forEach(function (err) {\n      var _err$message;\n      var separator = validationErrorMessage ? \"<br />\" : \"\";\n      validationErrorMessage += separator + encodeHtml(null !== (_err$message = null === err || void 0 === err ? void 0 : err.message) && void 0 !== _err$message ? _err$message : \"\");\n    });\n    return validationErrorMessage;\n  },\n  _toggleModeClass: function _toggleModeClass() {\n    var mode = this.option(\"mode\");\n    this.$wrapper().toggleClass(INVALID_MESSAGE_AUTO, \"auto\" === mode).toggleClass(INVALID_MESSAGE_ALWAYS, \"always\" === mode);\n  },\n  updateMaxWidth: function updateMaxWidth() {\n    var target = this.option(\"target\");\n    var targetWidth = getOuterWidth(target);\n    var maxWidth = \"100%\";\n    if (targetWidth) {\n      maxWidth = Math.max(targetWidth, VALIDATION_MESSAGE_MIN_WIDTH);\n    }\n    this.option({\n      maxWidth: maxWidth\n    });\n  },\n  _getPositionsArray: function _getPositionsArray(positionSide, rtlSide) {\n    switch (positionSide) {\n      case \"top\":\n        return [\"\".concat(rtlSide, \" bottom\"), \"\".concat(rtlSide, \" top\")];\n      case \"left\":\n        return [\"right\", \"left\"];\n      case \"right\":\n        return [\"left\", \"right\"];\n      default:\n        return [\"\".concat(rtlSide, \" top\"), \"\".concat(rtlSide, \" bottom\")];\n    }\n  },\n  _updatePosition: function _updatePosition() {\n    var _this$option4 = this.option(),\n      positionSide = _this$option4.positionSide,\n      rtlEnabled = _this$option4.rtlEnabled,\n      componentOffset = _this$option4.offset,\n      boundary = _this$option4.boundary;\n    var rtlSide = getDefaultAlignment(rtlEnabled);\n    var positions = this._getPositionsArray(positionSide, rtlSide);\n    var offset = _extends({}, componentOffset);\n    this.$element().addClass(\"dx-invalid-message-\".concat(positionSide));\n    if (rtlEnabled && \"left\" !== positionSide && \"right\" !== positionSide) {\n      offset.h = -offset.h;\n    }\n    if (\"top\" === positionSide) {\n      offset.v = -offset.v;\n    }\n    if (\"left\" === positionSide) {\n      offset.h = -offset.h;\n    }\n    this.option(\"position\", {\n      offset: offset,\n      boundary: boundary,\n      my: positions[0],\n      at: positions[1],\n      collision: \"none flip\"\n    });\n  },\n  _optionChanged: function _optionChanged(args) {\n    var name = args.name,\n      value = args.value,\n      previousValue = args.previousValue;\n    switch (name) {\n      case \"target\":\n        this._updatePositionByTarget();\n        this.updateMaxWidth();\n        this.callBase(args);\n        break;\n      case \"boundary\":\n        this.option(\"position.boundary\", value);\n        break;\n      case \"mode\":\n        this._toggleModeClass(value);\n        break;\n      case \"rtlEnabled\":\n      case \"offset\":\n      case \"positionSide\":\n        this.$element().removeClass(\"dx-invalid-message-\".concat(previousValue));\n        this._updatePosition();\n        break;\n      case \"container\":\n        this._updateContentId();\n        this.callBase(args);\n        break;\n      case \"contentId\":\n        this._updateContentId();\n        break;\n      case \"validationErrors\":\n        this._ensureMessageNotEmpty();\n        this._renderInnerHtml(this.$content());\n        break;\n      default:\n        this.callBase(args);\n    }\n  }\n});\nregisterComponent(\"dxValidationMessage\", ValidationMessage);\nexport default ValidationMessage;","map":null,"metadata":{},"sourceType":"module"}