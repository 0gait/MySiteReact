{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/appointments/dataProvider/utils.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport dateUtils from \"../../../../core/utils/date\";\nimport timeZoneUtils from \"../../utils.timeZone\";\nimport dateSerialization from \"../../../../core/utils/date_serialization\";\nimport { ExpressionUtils } from \"../../expressionUtils\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar FULL_DATE_FORMAT = \"yyyyMMddTHHmmss\";\nexport var compareDateWithStartDayHour = function compareDateWithStartDayHour(startDate, endDate, startDayHour, allDay, severalDays) {\n  var startTime = dateUtils.dateTimeFromDecimal(startDayHour);\n  var result = startDate.getHours() >= startTime.hours && startDate.getMinutes() >= startTime.minutes || endDate.getHours() === startTime.hours && endDate.getMinutes() > startTime.minutes || endDate.getHours() > startTime.hours || severalDays || allDay;\n  return result;\n};\nexport var compareDateWithEndDayHour = function compareDateWithEndDayHour(options) {\n  var startDate = options.startDate,\n    endDate = options.endDate,\n    startDayHour = options.startDayHour,\n    endDayHour = options.endDayHour,\n    viewStartDayHour = options.viewStartDayHour,\n    viewEndDayHour = options.viewEndDayHour,\n    allDay = options.allDay,\n    severalDays = options.severalDays,\n    min = options.min,\n    max = options.max,\n    checkIntersectViewport = options.checkIntersectViewport;\n  var hiddenInterval = (24 - viewEndDayHour + viewStartDayHour) * toMs(\"hour\");\n  var apptDuration = endDate.getTime() - startDate.getTime();\n  var delta = (hiddenInterval - apptDuration) / toMs(\"hour\");\n  var apptStartHour = startDate.getHours();\n  var apptStartMinutes = startDate.getMinutes();\n  var result;\n  var endTime = dateUtils.dateTimeFromDecimal(endDayHour);\n  var startTime = dateUtils.dateTimeFromDecimal(startDayHour);\n  var apptIntersectViewport = startDate < max && endDate > min;\n  result = checkIntersectViewport && apptIntersectViewport || apptStartHour < endTime.hours || apptStartHour === endTime.hours && apptStartMinutes < endTime.minutes || allDay && startDate <= max || severalDays && apptIntersectViewport && (apptStartHour < endTime.hours || 60 * endDate.getHours() + endDate.getMinutes() > 60 * startTime.hours);\n  if (apptDuration < hiddenInterval) {\n    if (apptStartHour > endTime.hours && apptStartMinutes > endTime.minutes && delta <= apptStartHour - endDayHour) {\n      result = false;\n    }\n  }\n  return result;\n};\nexport var getAppointmentTakesSeveralDays = function getAppointmentTakesSeveralDays(adapter) {\n  return !dateUtils.sameDate(adapter.startDate, adapter.endDate);\n};\nexport var _isEndDateWrong = function _isEndDateWrong(startDate, endDate) {\n  return !endDate || isNaN(endDate.getTime()) || startDate.getTime() > endDate.getTime();\n};\nexport var _appointmentPartInInterval = function _appointmentPartInInterval(startDate, endDate, startDayHour, endDayHour) {\n  var apptStartDayHour = startDate.getHours();\n  var apptEndDayHour = endDate.getHours();\n  return apptStartDayHour <= startDayHour && apptEndDayHour <= endDayHour && apptEndDayHour >= startDayHour || apptEndDayHour >= endDayHour && apptStartDayHour <= endDayHour && apptStartDayHour >= startDayHour;\n};\nexport var getRecurrenceException = function getRecurrenceException(appointmentAdapter, timeZoneCalculator, timeZone) {\n  var recurrenceException = appointmentAdapter.recurrenceException;\n  if (recurrenceException) {\n    var exceptions = recurrenceException.split(\",\");\n    for (var i = 0; i < exceptions.length; i++) {\n      exceptions[i] = _convertRecurrenceException(exceptions[i], appointmentAdapter.startDate, timeZoneCalculator, timeZone);\n    }\n    return exceptions.join();\n  }\n  return recurrenceException;\n};\nexport var _convertRecurrenceException = function _convertRecurrenceException(exceptionString, startDate, timeZoneCalculator, timeZone) {\n  exceptionString = exceptionString.replace(/\\s/g, \"\");\n  var getConvertedToTimeZone = function getConvertedToTimeZone(date) {\n    return timeZoneCalculator.createDate(date, {\n      path: \"toGrid\"\n    });\n  };\n  var exceptionDate = dateSerialization.deserializeDate(exceptionString);\n  var convertedStartDate = getConvertedToTimeZone(startDate);\n  var convertedExceptionDate = getConvertedToTimeZone(exceptionDate);\n  convertedExceptionDate = timeZoneUtils.correctRecurrenceExceptionByTimezone(convertedExceptionDate, convertedStartDate, timeZone);\n  exceptionString = dateSerialization.serializeDate(convertedExceptionDate, FULL_DATE_FORMAT);\n  return exceptionString;\n};\nexport var replaceWrongEndDate = function replaceWrongEndDate(appointment, startDate, endDate, appointmentDuration, dataAccessors) {\n  if (_isEndDateWrong(startDate, endDate)) {\n    var calculatedEndDate = function (isAllDay, startDate) {\n      if (isAllDay) {\n        return dateUtils.setToDayEnd(new Date(startDate));\n      }\n      return new Date(startDate.getTime() + appointmentDuration * toMs(\"minute\"));\n    }(appointment.allDay, startDate);\n    dataAccessors.setter.endDate(appointment, calculatedEndDate);\n  }\n};\nexport var sortAppointmentsByStartDate = function sortAppointmentsByStartDate(appointments, dataAccessors) {\n  appointments.sort(function (a, b) {\n    var firstDate = new Date(ExpressionUtils.getField(dataAccessors, \"startDate\", a.settings || a));\n    var secondDate = new Date(ExpressionUtils.getField(dataAccessors, \"startDate\", b.settings || b));\n    return Math.sign(firstDate.getTime() - secondDate.getTime());\n  });\n};","map":null,"metadata":{},"sourceType":"module"}