{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\MySiteReact\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\MySiteReact\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\MySiteReact\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\MySiteReact\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\MySiteReact\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\MySiteReact\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n/**\r\n * DevExtreme (esm/ui/toolbar/ui.toolbar.base.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getWidth, getOuterWidth, getHeight } from \"../../core/utils/size\";\nimport $ from \"../../core/renderer\";\nimport { isMaterial, waitWebFont } from \"../themes\";\nimport { isPlainObject, isDefined } from \"../../core/utils/type\";\nimport registerComponent from \"../../core/component_registrator\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { getBoundingRect } from \"../../core/utils/position\";\nimport AsyncCollectionWidget from \"../collection/ui.collection_widget.async\";\nimport { BindableTemplate } from \"../../core/templates/bindable_template\";\nimport fx from \"../../animation/fx\";\nimport { TOOLBAR_CLASS } from \"./constants\";\nvar TOOLBAR_BEFORE_CLASS = \"dx-toolbar-before\";\nvar TOOLBAR_CENTER_CLASS = \"dx-toolbar-center\";\nvar TOOLBAR_AFTER_CLASS = \"dx-toolbar-after\";\nvar TOOLBAR_MINI_CLASS = \"dx-toolbar-mini\";\nvar TOOLBAR_ITEM_CLASS = \"dx-toolbar-item\";\nvar TOOLBAR_LABEL_CLASS = \"dx-toolbar-label\";\nvar TOOLBAR_BUTTON_CLASS = \"dx-toolbar-button\";\nvar TOOLBAR_ITEMS_CONTAINER_CLASS = \"dx-toolbar-items-container\";\nvar TOOLBAR_GROUP_CLASS = \"dx-toolbar-group\";\nvar TOOLBAR_COMPACT_CLASS = \"dx-toolbar-compact\";\nvar TEXT_BUTTON_MODE = \"text\";\nvar DEFAULT_BUTTON_TYPE = \"default\";\nvar DEFAULT_DROPDOWNBUTTON_STYLING_MODE = \"contained\";\nvar TOOLBAR_ITEM_DATA_KEY = \"dxToolbarItemDataKey\";\nvar ANIMATION_TIMEOUT = 15;\nvar ToolbarBase = /*#__PURE__*/function (_AsyncCollectionWidge) {\n  _inherits(ToolbarBase, _AsyncCollectionWidge);\n  function ToolbarBase() {\n    _classCallCheck(this, ToolbarBase);\n    return _possibleConstructorReturn(this, _getPrototypeOf(ToolbarBase).apply(this, arguments));\n  }\n  _createClass(ToolbarBase, [{\n    key: \"_getSynchronizableOptionsForCreateComponent\",\n    value: function _getSynchronizableOptionsForCreateComponent() {\n      return _get(_getPrototypeOf(ToolbarBase.prototype), \"_getSynchronizableOptionsForCreateComponent\", this).call(this).filter(function (item) {\n        return \"disabled\" !== item;\n      });\n    }\n  }, {\n    key: \"_initTemplates\",\n    value: function _initTemplates() {\n      _get(_getPrototypeOf(ToolbarBase.prototype), \"_initTemplates\", this).call(this);\n      var template = new BindableTemplate(function ($container, data, rawModel) {\n        if (isPlainObject(data)) {\n          var text = data.text,\n            html = data.html,\n            widget = data.widget;\n          if (text) {\n            $container.text(text).wrapInner(\"<div>\");\n          }\n          if (html) {\n            $container.html(html);\n          }\n          if (\"dxDropDownButton\" === widget) {\n            var _data$options;\n            data.options = null !== (_data$options = data.options) && void 0 !== _data$options ? _data$options : {};\n            if (!isDefined(data.options.stylingMode)) {\n              data.options.stylingMode = this.option(\"useFlatButtons\") ? TEXT_BUTTON_MODE : DEFAULT_DROPDOWNBUTTON_STYLING_MODE;\n            }\n          }\n          if (\"dxButton\" === widget) {\n            if (this.option(\"useFlatButtons\")) {\n              var _data$options2, _data$options$styling;\n              data.options = null !== (_data$options2 = data.options) && void 0 !== _data$options2 ? _data$options2 : {};\n              data.options.stylingMode = null !== (_data$options$styling = data.options.stylingMode) && void 0 !== _data$options$styling ? _data$options$styling : TEXT_BUTTON_MODE;\n            }\n            if (this.option(\"useDefaultButtons\")) {\n              var _data$options3, _data$options$type;\n              data.options = null !== (_data$options3 = data.options) && void 0 !== _data$options3 ? _data$options3 : {};\n              data.options.type = null !== (_data$options$type = data.options.type) && void 0 !== _data$options$type ? _data$options$type : DEFAULT_BUTTON_TYPE;\n            }\n          }\n        } else {\n          $container.text(String(data));\n        }\n        this._getTemplate(\"dx-polymorph-widget\").render({\n          container: $container,\n          model: rawModel,\n          parent: this\n        });\n      }.bind(this), [\"text\", \"html\", \"widget\", \"options\"], this.option(\"integrationOptions.watchMethod\"));\n      this._templateManager.addDefaultTemplates({\n        item: template,\n        menuItem: template\n      });\n    }\n  }, {\n    key: \"_getDefaultOptions\",\n    value: function _getDefaultOptions() {\n      return extend(_get(_getPrototypeOf(ToolbarBase.prototype), \"_getDefaultOptions\", this).call(this), {\n        renderAs: \"topToolbar\",\n        grouped: false,\n        useFlatButtons: false,\n        useDefaultButtons: false\n      });\n    }\n  }, {\n    key: \"_defaultOptionsRules\",\n    value: function _defaultOptionsRules() {\n      return _get(_getPrototypeOf(ToolbarBase.prototype), \"_defaultOptionsRules\", this).call(this).concat([{\n        device: function device() {\n          return isMaterial();\n        },\n        options: {\n          useFlatButtons: true\n        }\n      }]);\n    }\n  }, {\n    key: \"_itemContainer\",\n    value: function _itemContainer() {\n      return this._$toolbarItemsContainer.find([\".\".concat(TOOLBAR_BEFORE_CLASS), \".\".concat(TOOLBAR_CENTER_CLASS), \".\".concat(TOOLBAR_AFTER_CLASS)].join(\",\"));\n    }\n  }, {\n    key: \"_itemClass\",\n    value: function _itemClass() {\n      return TOOLBAR_ITEM_CLASS;\n    }\n  }, {\n    key: \"_itemDataKey\",\n    value: function _itemDataKey() {\n      return TOOLBAR_ITEM_DATA_KEY;\n    }\n  }, {\n    key: \"_dimensionChanged\",\n    value: function _dimensionChanged() {\n      this._arrangeItems();\n      this._applyCompactMode();\n    }\n  }, {\n    key: \"_initMarkup\",\n    value: function _initMarkup() {\n      this._renderToolbar();\n      this._renderSections();\n      _get(_getPrototypeOf(ToolbarBase.prototype), \"_initMarkup\", this).call(this);\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      _get(_getPrototypeOf(ToolbarBase.prototype), \"_render\", this).call(this);\n      this._renderItemsAsync();\n      this._updateDimensionsInMaterial();\n    }\n  }, {\n    key: \"_postProcessRenderItems\",\n    value: function _postProcessRenderItems() {\n      this._arrangeItems();\n    }\n  }, {\n    key: \"_renderToolbar\",\n    value: function _renderToolbar() {\n      this.$element().addClass(TOOLBAR_CLASS);\n      this._$toolbarItemsContainer = $(\"<div>\").addClass(TOOLBAR_ITEMS_CONTAINER_CLASS).appendTo(this.$element());\n      this.setAria(\"role\", \"toolbar\");\n    }\n  }, {\n    key: \"_renderSections\",\n    value: function _renderSections() {\n      var _this = this;\n      var $container = this._$toolbarItemsContainer;\n      each([\"before\", \"center\", \"after\"], function (_, section) {\n        var sectionClass = \"dx-toolbar-\".concat(section);\n        var $section = $container.find(\".\".concat(sectionClass));\n        if (!$section.length) {\n          _this[\"_$\".concat(section, \"Section\")] = $(\"<div>\").addClass(sectionClass).appendTo($container);\n        }\n      });\n    }\n  }, {\n    key: \"_arrangeItems\",\n    value: function _arrangeItems(elementWidth) {\n      var _elementWidth;\n      elementWidth = null !== (_elementWidth = elementWidth) && void 0 !== _elementWidth ? _elementWidth : getWidth(this.$element());\n      this._$centerSection.css({\n        margin: \"0 auto\",\n        float: \"none\"\n      });\n      var beforeRect = getBoundingRect(this._$beforeSection.get(0));\n      var afterRect = getBoundingRect(this._$afterSection.get(0));\n      this._alignCenterSection(beforeRect, afterRect, elementWidth);\n      var $label = this._$toolbarItemsContainer.find(\".\".concat(TOOLBAR_LABEL_CLASS)).eq(0);\n      var $section = $label.parent();\n      if (!$label.length) {\n        return;\n      }\n      var labelOffset = beforeRect.width ? beforeRect.width : $label.position().left;\n      var widthBeforeSection = $section.hasClass(TOOLBAR_BEFORE_CLASS) ? 0 : labelOffset;\n      var widthAfterSection = $section.hasClass(TOOLBAR_AFTER_CLASS) ? 0 : afterRect.width;\n      var elemsAtSectionWidth = 0;\n      $section.children().not(\".\".concat(TOOLBAR_LABEL_CLASS)).each(function () {\n        elemsAtSectionWidth += getOuterWidth(this);\n      });\n      var freeSpace = elementWidth - elemsAtSectionWidth;\n      var sectionMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection, 0);\n      if ($section.hasClass(TOOLBAR_BEFORE_CLASS)) {\n        this._alignSection(this._$beforeSection, sectionMaxWidth);\n      } else {\n        var labelPaddings = getOuterWidth($label) - getWidth($label);\n        $label.css(\"maxWidth\", sectionMaxWidth - labelPaddings);\n      }\n    }\n  }, {\n    key: \"_alignCenterSection\",\n    value: function _alignCenterSection(beforeRect, afterRect, elementWidth) {\n      this._alignSection(this._$centerSection, elementWidth - beforeRect.width - afterRect.width);\n      var isRTL = this.option(\"rtlEnabled\");\n      var leftRect = isRTL ? afterRect : beforeRect;\n      var rightRect = isRTL ? beforeRect : afterRect;\n      var centerRect = getBoundingRect(this._$centerSection.get(0));\n      if (leftRect.right > centerRect.left || centerRect.right > rightRect.left) {\n        this._$centerSection.css({\n          marginLeft: leftRect.width,\n          marginRight: rightRect.width,\n          float: leftRect.width > rightRect.width ? \"none\" : \"right\"\n        });\n      }\n    }\n  }, {\n    key: \"_alignSection\",\n    value: function _alignSection($section, maxWidth) {\n      var $labels = $section.find(\".\".concat(TOOLBAR_LABEL_CLASS));\n      var labels = $labels.toArray();\n      maxWidth -= this._getCurrentLabelsPaddings(labels);\n      var currentWidth = this._getCurrentLabelsWidth(labels);\n      var difference = Math.abs(currentWidth - maxWidth);\n      if (maxWidth < currentWidth) {\n        labels = labels.reverse();\n        this._alignSectionLabels(labels, difference, false);\n      } else {\n        this._alignSectionLabels(labels, difference, true);\n      }\n    }\n  }, {\n    key: \"_alignSectionLabels\",\n    value: function _alignSectionLabels(labels, difference, expanding) {\n      var getRealLabelWidth = function getRealLabelWidth(label) {\n        return getBoundingRect(label).width;\n      };\n      for (var i = 0; i < labels.length; i++) {\n        var $label = $(labels[i]);\n        var currentLabelWidth = Math.ceil(getRealLabelWidth(labels[i]));\n        var labelMaxWidth = void 0;\n        if (expanding) {\n          $label.css(\"maxWidth\", \"inherit\");\n        }\n        var possibleLabelWidth = Math.ceil(expanding ? getRealLabelWidth(labels[i]) : currentLabelWidth);\n        if (possibleLabelWidth < difference) {\n          labelMaxWidth = expanding ? possibleLabelWidth : 0;\n          difference -= possibleLabelWidth;\n        } else {\n          labelMaxWidth = expanding ? currentLabelWidth + difference : currentLabelWidth - difference;\n          $label.css(\"maxWidth\", labelMaxWidth);\n          break;\n        }\n        $label.css(\"maxWidth\", labelMaxWidth);\n      }\n    }\n  }, {\n    key: \"_applyCompactMode\",\n    value: function _applyCompactMode() {\n      var $element = this.$element();\n      $element.removeClass(TOOLBAR_COMPACT_CLASS);\n      if (this.option(\"compactMode\") && this._getSummaryItemsWidth(this.itemElements(), true) > getWidth($element)) {\n        $element.addClass(TOOLBAR_COMPACT_CLASS);\n      }\n    }\n  }, {\n    key: \"_getCurrentLabelsWidth\",\n    value: function _getCurrentLabelsWidth(labels) {\n      var width = 0;\n      labels.forEach(function (label, index) {\n        width += getOuterWidth(label);\n      });\n      return width;\n    }\n  }, {\n    key: \"_getCurrentLabelsPaddings\",\n    value: function _getCurrentLabelsPaddings(labels) {\n      var padding = 0;\n      labels.forEach(function (label, index) {\n        padding += getOuterWidth(label) - getWidth(label);\n      });\n      return padding;\n    }\n  }, {\n    key: \"_renderItem\",\n    value: function _renderItem(index, item, itemContainer, $after) {\n      var _item$location, _item$text;\n      var location = null !== (_item$location = item.location) && void 0 !== _item$location ? _item$location : \"center\";\n      var container = null !== itemContainer && void 0 !== itemContainer ? itemContainer : this[\"_$\".concat(location, \"Section\")];\n      var itemHasText = !!(null !== (_item$text = item.text) && void 0 !== _item$text ? _item$text : item.html);\n      var itemElement = _get(_getPrototypeOf(ToolbarBase.prototype), \"_renderItem\", this).call(this, index, item, container, $after);\n      itemElement.toggleClass(TOOLBAR_BUTTON_CLASS, !itemHasText).toggleClass(TOOLBAR_LABEL_CLASS, itemHasText).addClass(item.cssClass);\n      return itemElement;\n    }\n  }, {\n    key: \"_renderGroupedItems\",\n    value: function _renderGroupedItems() {\n      var _this2 = this;\n      each(this.option(\"items\"), function (groupIndex, group) {\n        var _group$location;\n        var groupItems = group.items;\n        var $container = $(\"<div>\").addClass(TOOLBAR_GROUP_CLASS);\n        var location = null !== (_group$location = group.location) && void 0 !== _group$location ? _group$location : \"center\";\n        if (!groupItems || !groupItems.length) {\n          return;\n        }\n        each(groupItems, function (itemIndex, item) {\n          _this2._renderItem(itemIndex, item, $container, null);\n        });\n        _this2._$toolbarItemsContainer.find(\".dx-toolbar-\".concat(location)).append($container);\n      });\n    }\n  }, {\n    key: \"_renderItems\",\n    value: function _renderItems(items) {\n      var grouped = this.option(\"grouped\") && items.length && items[0].items;\n      grouped ? this._renderGroupedItems() : _get(_getPrototypeOf(ToolbarBase.prototype), \"_renderItems\", this).call(this, items);\n    }\n  }, {\n    key: \"_getToolbarItems\",\n    value: function _getToolbarItems() {\n      var _this$option;\n      return null !== (_this$option = this.option(\"items\")) && void 0 !== _this$option ? _this$option : [];\n    }\n  }, {\n    key: \"_renderContentImpl\",\n    value: function _renderContentImpl() {\n      var items = this._getToolbarItems();\n      this.$element().toggleClass(TOOLBAR_MINI_CLASS, 0 === items.length);\n      if (this._renderedItemsCount) {\n        this._renderItems(items.slice(this._renderedItemsCount));\n      } else {\n        this._renderItems(items);\n      }\n      this._applyCompactMode();\n    }\n  }, {\n    key: \"_renderEmptyMessage\",\n    value: function _renderEmptyMessage() {}\n  }, {\n    key: \"_clean\",\n    value: function _clean() {\n      this._$toolbarItemsContainer.children().empty();\n      this.$element().empty();\n      delete this._$beforeSection;\n      delete this._$centerSection;\n      delete this._$afterSection;\n    }\n  }, {\n    key: \"_visibilityChanged\",\n    value: function _visibilityChanged(visible) {\n      if (visible) {\n        this._arrangeItems();\n      }\n    }\n  }, {\n    key: \"_isVisible\",\n    value: function _isVisible() {\n      return getWidth(this.$element()) > 0 && getHeight(this.$element()) > 0;\n    }\n  }, {\n    key: \"_getIndexByItem\",\n    value: function _getIndexByItem(item) {\n      return this._getToolbarItems().indexOf(item);\n    }\n  }, {\n    key: \"_itemOptionChanged\",\n    value: function _itemOptionChanged(item, property, value) {\n      _get(_getPrototypeOf(ToolbarBase.prototype), \"_itemOptionChanged\", this).apply(this, [item, property, value]);\n      this._arrangeItems();\n    }\n  }, {\n    key: \"_optionChanged\",\n    value: function _optionChanged(_ref) {\n      var name = _ref.name,\n        value = _ref.value;\n      switch (name) {\n        case \"width\":\n          _get(_getPrototypeOf(ToolbarBase.prototype), \"_optionChanged\", this).apply(this, arguments);\n          this._dimensionChanged();\n          break;\n        case \"renderAs\":\n        case \"useFlatButtons\":\n        case \"useDefaultButtons\":\n          this._invalidate();\n          break;\n        case \"compactMode\":\n          this._applyCompactMode();\n          break;\n        case \"grouped\":\n          break;\n        default:\n          _get(_getPrototypeOf(ToolbarBase.prototype), \"_optionChanged\", this).apply(this, arguments);\n      }\n    }\n  }, {\n    key: \"_dispose\",\n    value: function _dispose() {\n      _get(_getPrototypeOf(ToolbarBase.prototype), \"_dispose\", this).call(this);\n      clearTimeout(this._waitParentAnimationTimeout);\n    }\n  }, {\n    key: \"_updateDimensionsInMaterial\",\n    value: function _updateDimensionsInMaterial() {\n      var _this3 = this;\n      if (isMaterial()) {\n        Promise.all([function () {\n          return new Promise(function (resolve) {\n            var check = function check() {\n              var readyToResolve = true;\n              _this3.$element().parents().each(function (_, parent) {\n                if (fx.isAnimating($(parent))) {\n                  readyToResolve = false;\n                  return false;\n                }\n              });\n              if (readyToResolve) {\n                resolve();\n              }\n              return readyToResolve;\n            };\n            var runCheck = function runCheck() {\n              clearTimeout(_this3._waitParentAnimationTimeout);\n              _this3._waitParentAnimationTimeout = setTimeout(function () {\n                return check() || runCheck();\n              }, ANIMATION_TIMEOUT);\n            };\n            runCheck();\n          });\n        }(), function () {\n          var $labels = _this3.$element().find(\".\".concat(TOOLBAR_LABEL_CLASS));\n          var promises = [];\n          $labels.each(function (_, label) {\n            var text = $(label).text();\n            var fontWeight = $(label).css(\"fontWeight\");\n            promises.push(waitWebFont(text, fontWeight));\n          });\n          return Promise.all(promises);\n        }()]).then(function () {\n          _this3._dimensionChanged();\n        });\n      }\n    }\n  }]);\n  return ToolbarBase;\n}(AsyncCollectionWidget);\nregisterComponent(\"dxToolbarBase\", ToolbarBase);\nexport default ToolbarBase;","map":null,"metadata":{},"sourceType":"module"}