{"ast":null,"code":"/*!\n * devextreme-react\n * Version: 22.2.4\n * Build date: Thu Jan 19 2023\n *\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\n *\n * This software may be modified and distributed under the terms\n * of the MIT license. See the LICENSE file in the root of the project for details.\n *\n * https://github.com/DevExpress/devextreme-react\n */\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OptionsManager = exports.scheduleGuards = exports.unscheduleGuards = void 0;\n/* eslint-disable no-restricted-globals */\nvar comparer_1 = require(\"./configuration/comparer\");\nvar tree_1 = require(\"./configuration/tree\");\nvar utils_1 = require(\"./configuration/utils\");\nvar helpers_1 = require(\"./helpers\");\nvar optionsManagers = new Set();\nvar guardTimeoutHandler = -1;\nfunction unscheduleGuards() {\n  clearTimeout(guardTimeoutHandler);\n}\nexports.unscheduleGuards = unscheduleGuards;\nfunction scheduleGuards() {\n  unscheduleGuards();\n  guardTimeoutHandler = window.setTimeout(function () {\n    optionsManagers.forEach(function (optionManager) {\n      return optionManager.execGuards();\n    });\n  });\n}\nexports.scheduleGuards = scheduleGuards;\nvar OptionsManager = /** @class */function () {\n  function OptionsManager(templatesManager) {\n    this.guards = {};\n    this.isUpdating = false;\n    this.templatesManager = templatesManager;\n    optionsManagers.add(this);\n    this.onOptionChanged = this.onOptionChanged.bind(this);\n    this.wrapOptionValue = this.wrapOptionValue.bind(this);\n  }\n  OptionsManager.prototype.setInstance = function (instance, config, subscribableOptions, independentEvents) {\n    this.instance = instance;\n    this.currentConfig = config;\n    this.subscribableOptions = new Set(subscribableOptions);\n    this.independentEvents = new Set(independentEvents);\n  };\n  OptionsManager.prototype.getInitialOptions = function (rootNode) {\n    var _this = this;\n    var config = tree_1.buildConfig(rootNode, false);\n    Object.keys(config.templates).forEach(function (key) {\n      _this.templatesManager.add(key, config.templates[key]);\n    });\n    var options = {};\n    Object.keys(config.options).forEach(function (key) {\n      options[key] = _this.wrapOptionValue(key, config.options[key]);\n    });\n    if (this.templatesManager.templatesCount > 0) {\n      options.integrationOptions = {\n        templates: this.templatesManager.templates\n      };\n    }\n    return options;\n  };\n  OptionsManager.prototype.update = function (config) {\n    var _this = this;\n    var changedOptions = [];\n    var optionChangedHandler = function optionChangedHandler(_a) {\n      var value = _a.value,\n        fullName = _a.fullName;\n      changedOptions.push([fullName, value]);\n    };\n    this.instance.on('optionChanged', optionChangedHandler);\n    var changes = comparer_1.getChanges(config, this.currentConfig);\n    if (!changes.options && !changes.templates && !changes.removedOptions.length) {\n      return;\n    }\n    this.instance.beginUpdate();\n    this.isUpdating = true;\n    changes.removedOptions.forEach(function (optionName) {\n      _this.resetOption(optionName);\n    });\n    Object.keys(changes.templates).forEach(function (key) {\n      _this.templatesManager.add(key, changes.templates[key]);\n    });\n    if (this.templatesManager.templatesCount > 0) {\n      this.setValue('integrationOptions', {\n        templates: this.templatesManager.templates\n      });\n    }\n    Object.keys(changes.options).forEach(function (key) {\n      _this.setValue(key, changes.options[key]);\n    });\n    this.isUpdating = false;\n    this.instance.off('optionChanged', optionChangedHandler);\n    this.currentConfig = config;\n    changedOptions.forEach(function (_a) {\n      var name = _a[0],\n        value = _a[1];\n      var currentPropValue = config.options[name];\n      if (Object.prototype.hasOwnProperty.call(config.options, name) && currentPropValue !== value) {\n        _this.setValue(name, currentPropValue);\n      }\n    });\n    this.instance.endUpdate();\n  };\n  OptionsManager.prototype.onOptionChanged = function (e) {\n    var _this = this;\n    var _a;\n    if (this.isUpdating) {\n      return;\n    }\n    var valueDescriptor = tree_1.findValue(this.currentConfig, e.fullName.split('.'));\n    if (!valueDescriptor || valueDescriptor.value !== e.value) {\n      this.callOptionChangeHandler(e.fullName, e.value);\n    }\n    valueDescriptor = tree_1.findValue(this.currentConfig, e.fullName.split('.'));\n    if (!valueDescriptor) {\n      return;\n    }\n    var value = valueDescriptor.value,\n      type = valueDescriptor.type;\n    if (value instanceof Array && type === tree_1.ValueType.Array) {\n      for (var i = 0; i < value.length; i += 1) {\n        if (value[i] !== ((_a = e.value) === null || _a === void 0 ? void 0 : _a[i])) {\n          this.addGuard(e.fullName, value);\n          return;\n        }\n      }\n    } else if (type === tree_1.ValueType.Complex && value instanceof Object) {\n      Object.keys(value).forEach(function (key) {\n        var _a;\n        if (value[key] === ((_a = e.value) === null || _a === void 0 ? void 0 : _a[key])) {\n          return;\n        }\n        _this.addGuard(utils_1.mergeNameParts(e.fullName, key), value[key]);\n      });\n    } else {\n      var valuesAreEqual = value === e.value;\n      var valuesAreEqualObjects = !valuesAreEqual && value instanceof Object && e.value instanceof Object && utils_1.shallowEquals(value, e.value);\n      if (valuesAreEqual || valuesAreEqualObjects || this.instance.skipOptionsRollBack) {\n        return;\n      }\n      this.addGuard(e.fullName, value);\n    }\n  };\n  OptionsManager.prototype.dispose = function () {\n    var _this = this;\n    optionsManagers.delete(this);\n    Object.keys(this.guards).forEach(function (optionName) {\n      delete _this.guards[optionName];\n    });\n  };\n  OptionsManager.prototype.isOptionSubscribable = function (optionName) {\n    return this.subscribableOptions.has(optionName);\n  };\n  OptionsManager.prototype.isIndependentEvent = function (optionName) {\n    return this.independentEvents.has(optionName);\n  };\n  OptionsManager.prototype.callOptionChangeHandler = function (optionName, optionValue) {\n    if (!this.isOptionSubscribable(optionName)) {\n      return;\n    }\n    var parts = optionName.split('.');\n    var propName = parts[parts.length - 1];\n    if (propName.startsWith('on')) {\n      return;\n    }\n    var eventName = \"on\" + helpers_1.capitalizeFirstLetter(propName) + \"Change\";\n    parts[parts.length - 1] = eventName;\n    var changeEvent = tree_1.findValue(this.currentConfig, parts);\n    if (!changeEvent) {\n      return;\n    }\n    if (typeof changeEvent.value !== 'function') {\n      throw new Error(\"Invalid value for the \" + eventName + \" property.\\n                \" + eventName + \" must be a function.\");\n    }\n    changeEvent.value(optionValue);\n  };\n  OptionsManager.prototype.wrapOptionValue = function (name, value) {\n    var _this = this;\n    if (name.substr(0, 2) === 'on' && typeof value === 'function') {\n      return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        if (!_this.isUpdating || _this.isIndependentEvent(name)) {\n          value.apply(void 0, args);\n        }\n      };\n    }\n    return value;\n  };\n  OptionsManager.prototype.addGuard = function (optionName, optionValue) {\n    var _this = this;\n    if (this.guards[optionName] !== undefined) {\n      return;\n    }\n    var handler = function handler() {\n      _this.setValue(optionName, optionValue);\n      delete _this.guards[optionName];\n    };\n    this.guards[optionName] = handler;\n    scheduleGuards();\n  };\n  OptionsManager.prototype.execGuards = function () {\n    Object.values(this.guards).forEach(function (handler) {\n      return handler();\n    });\n  };\n  OptionsManager.prototype.resetOption = function (name) {\n    this.instance.resetOption(name);\n  };\n  OptionsManager.prototype.setValue = function (name, value) {\n    if (this.guards[name]) {\n      delete this.guards[name];\n    }\n    this.instance.option(name, this.wrapOptionValue(name, value));\n  };\n  return OptionsManager;\n}();\nexports.OptionsManager = OptionsManager;","map":null,"metadata":{},"sourceType":"script"}