{"ast":null,"code":"import _possibleConstructorReturn from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _slicedToArray from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n/**\r\n * DevExtreme (esm/ui/scheduler/appointments/dataProvider/appointmentFilter.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../../core/utils/date\";\nimport { getRecurrenceProcessor } from \"../../recurrence\";\nimport { wrapToArray } from \"../../../../core/utils/array\";\nimport { map, each } from \"../../../../core/utils/iterator\";\nimport { isFunction, isDefined } from \"../../../../core/utils/type\";\nimport query from \"../../../../data/query\";\nimport { createAppointmentAdapter } from \"../../appointmentAdapter\";\nimport { hasResourceValue } from \"../../../../renovation/ui/scheduler/resources/hasResourceValue\";\nimport { isDateAndTimeView as calculateIsDateAndTimeView, isTimelineView } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { getResourcesDataByGroups } from \"../../resources/utils\";\nimport { compareDateWithStartDayHour, compareDateWithEndDayHour, getAppointmentTakesSeveralDays, _appointmentPartInInterval, getRecurrenceException } from \"./utils\";\nimport getDatesWithoutTime from \"../../../../renovation/ui/scheduler/utils/filtering/getDatesWithoutTime\";\nimport { getAppointmentTakesAllDay } from \"../../../../renovation/ui/scheduler/appointment/utils/getAppointmentTakesAllDay\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar FilterStrategies = {\n  virtual: \"virtual\",\n  standard: \"standard\"\n};\nexport var AppointmentFilterBaseStrategy = /*#__PURE__*/function () {\n  function AppointmentFilterBaseStrategy(options) {\n    _classCallCheck(this, AppointmentFilterBaseStrategy);\n    this.options = options;\n    this.dataAccessors = this.options.dataAccessors;\n    this._init();\n  }\n  _createClass(AppointmentFilterBaseStrategy, [{\n    key: \"_resolveOption\",\n    value: function _resolveOption(name) {\n      var result = this.options[name];\n      return \"function\" === typeof result ? result() : result;\n    }\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      this.setDataAccessors(this.dataAccessors);\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(preparedItems) {\n      var dateRange = this.dateRange;\n      var allDay;\n      if (!this.showAllDayPanel && this.supportAllDayRow) {\n        allDay = false;\n      }\n      return this.filterLoadedAppointments({\n        startDayHour: this.viewStartDayHour,\n        endDayHour: this.viewEndDayHour,\n        viewStartDayHour: this.viewStartDayHour,\n        viewEndDayHour: this.viewEndDayHour,\n        min: dateRange[0],\n        max: dateRange[1],\n        resources: this.loadedResources,\n        allDay: allDay,\n        supportMultiDayAppointments: isTimelineView(this.viewType),\n        firstDayOfWeek: this.firstDayOfWeek\n      }, preparedItems);\n    }\n  }, {\n    key: \"hasAllDayAppointments\",\n    value: function hasAllDayAppointments(filteredItems, preparedItems) {\n      var _this = this;\n      var adapters = filteredItems.map(function (item) {\n        return createAppointmentAdapter(item, _this.dataAccessors, _this.timeZoneCalculator);\n      });\n      var result = false;\n      each(adapters, function (_, item) {\n        if (getAppointmentTakesAllDay(item, _this.viewStartDayHour, _this.viewEndDayHour, _this.allDayPanelMode)) {\n          result = true;\n          return false;\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"setDataAccessors\",\n    value: function setDataAccessors(dataAccessors) {\n      this.dataAccessors = dataAccessors;\n    }\n  }, {\n    key: \"_createAllDayAppointmentFilter\",\n    value: function _createAllDayAppointmentFilter(filterOptions) {\n      var _this2 = this;\n      var viewStartDayHour = filterOptions.viewStartDayHour,\n        viewEndDayHour = filterOptions.viewEndDayHour;\n      return [[function (appointment) {\n        return getAppointmentTakesAllDay(appointment, viewStartDayHour, viewEndDayHour, _this2.allDayPanelMode);\n      }]];\n    }\n  }, {\n    key: \"_createCombinedFilter\",\n    value: function _createCombinedFilter(filterOptions) {\n      var _this3 = this;\n      var min = new Date(filterOptions.min);\n      var max = new Date(filterOptions.max);\n      var startDayHour = filterOptions.startDayHour,\n        endDayHour = filterOptions.endDayHour,\n        viewStartDayHour = filterOptions.viewStartDayHour,\n        viewEndDayHour = filterOptions.viewEndDayHour,\n        resources = filterOptions.resources,\n        firstDayOfWeek = filterOptions.firstDayOfWeek,\n        checkIntersectViewport = filterOptions.checkIntersectViewport,\n        supportMultiDayAppointments = filterOptions.supportMultiDayAppointments;\n      var _getDatesWithoutTime = getDatesWithoutTime(min, max),\n        _getDatesWithoutTime2 = _slicedToArray(_getDatesWithoutTime, 2),\n        trimMin = _getDatesWithoutTime2[0],\n        trimMax = _getDatesWithoutTime2[1];\n      var useRecurrence = isDefined(this.dataAccessors.getter.recurrenceRule);\n      return [[function (appointment) {\n        var _appointment$visible;\n        var appointmentVisible = null !== (_appointment$visible = appointment.visible) && void 0 !== _appointment$visible ? _appointment$visible : true;\n        if (!appointmentVisible) {\n          return false;\n        }\n        var startDate = appointment.startDate,\n          endDate = appointment.endDate,\n          hasRecurrenceRule = appointment.hasRecurrenceRule;\n        if (!hasRecurrenceRule) {\n          if (!(endDate >= trimMin && startDate < trimMax || dateUtils.sameDate(endDate, trimMin) && dateUtils.sameDate(startDate, trimMin))) {\n            return false;\n          }\n        }\n        var appointmentTakesAllDay = getAppointmentTakesAllDay(appointment, viewStartDayHour, viewEndDayHour, _this3.allDayPanelMode);\n        var appointmentTakesSeveralDays = getAppointmentTakesSeveralDays(appointment);\n        var isAllDay = appointment.allDay;\n        var isLongAppointment = appointmentTakesSeveralDays || appointmentTakesAllDay;\n        if (null !== resources && void 0 !== resources && resources.length && !_this3._filterAppointmentByResources(appointment.rawAppointment, resources)) {\n          return false;\n        }\n        if (appointmentTakesAllDay && false === filterOptions.allDay) {\n          return false;\n        }\n        if (hasRecurrenceRule) {\n          var recurrenceException = getRecurrenceException(appointment, _this3.timeZoneCalculator, _this3.timezone);\n          if (!_this3._filterAppointmentByRRule(_extends({}, appointment, {\n            recurrenceException: recurrenceException,\n            allDay: appointmentTakesAllDay\n          }), min, max, startDayHour, endDayHour, firstDayOfWeek)) {\n            return false;\n          }\n        }\n        if (!isAllDay && supportMultiDayAppointments && isLongAppointment) {\n          if (endDate < min && (!useRecurrence || useRecurrence && !hasRecurrenceRule)) {\n            return false;\n          }\n        }\n        if (isDefined(startDayHour) && (!useRecurrence || !filterOptions.isVirtualScrolling)) {\n          if (!compareDateWithStartDayHour(startDate, endDate, startDayHour, appointmentTakesAllDay, appointmentTakesSeveralDays)) {\n            return false;\n          }\n        }\n        if (isDefined(endDayHour)) {\n          if (!compareDateWithEndDayHour({\n            startDate: startDate,\n            endDate: endDate,\n            startDayHour: startDayHour,\n            endDayHour: endDayHour,\n            viewStartDayHour: viewStartDayHour,\n            viewEndDayHour: viewEndDayHour,\n            allDay: appointmentTakesAllDay,\n            severalDays: appointmentTakesSeveralDays,\n            min: min,\n            max: max,\n            checkIntersectViewport: checkIntersectViewport\n          })) {\n            return false;\n          }\n        }\n        if (!isAllDay && (!isLongAppointment || supportMultiDayAppointments)) {\n          if (endDate < min && useRecurrence && !hasRecurrenceRule) {\n            return false;\n          }\n        }\n        return true;\n      }]];\n    }\n  }, {\n    key: \"_createAppointmentFilter\",\n    value: function _createAppointmentFilter(filterOptions) {\n      return this._createCombinedFilter(filterOptions);\n    }\n  }, {\n    key: \"_filterAppointmentByResources\",\n    value: function _filterAppointmentByResources(appointment, resources) {\n      var _this4 = this;\n      var checkAppointmentResourceValues = function checkAppointmentResourceValues(resourceName, resourceIndex) {\n        var resourceGetter = _this4.dataAccessors.resources.getter[resourceName];\n        var resource;\n        if (isFunction(resourceGetter)) {\n          resource = resourceGetter(appointment);\n        }\n        var appointmentResourceValues = wrapToArray(resource);\n        var resourceData = map(resources[resourceIndex].items, function (_ref) {\n          var id = _ref.id;\n          return id;\n        });\n        for (var i = 0; i < appointmentResourceValues.length; i++) {\n          if (hasResourceValue(resourceData, appointmentResourceValues[i])) {\n            return true;\n          }\n        }\n        return false;\n      };\n      var result = false;\n      for (var i = 0; i < resources.length; i++) {\n        var resourceName = resources[i].name;\n        result = checkAppointmentResourceValues(resourceName, i);\n        if (!result) {\n          return false;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"_filterAppointmentByRRule\",\n    value: function _filterAppointmentByRRule(appointment, min, max, startDayHour, endDayHour, firstDayOfWeek) {\n      var recurrenceRule = appointment.recurrenceRule;\n      var recurrenceException = appointment.recurrenceException;\n      var allDay = appointment.allDay;\n      var result = true;\n      var appointmentStartDate = appointment.startDate;\n      var appointmentEndDate = appointment.endDate;\n      var recurrenceProcessor = getRecurrenceProcessor();\n      if (allDay || _appointmentPartInInterval(appointmentStartDate, appointmentEndDate, startDayHour, endDayHour)) {\n        var _getDatesWithoutTime3 = getDatesWithoutTime(min, max),\n          _getDatesWithoutTime4 = _slicedToArray(_getDatesWithoutTime3, 2),\n          trimMin = _getDatesWithoutTime4[0],\n          trimMax = _getDatesWithoutTime4[1];\n        min = trimMin;\n        max = new Date(trimMax.getTime() - toMs(\"minute\"));\n      }\n      if (recurrenceRule && !recurrenceProcessor.isValidRecurrenceRule(recurrenceRule)) {\n        result = appointmentEndDate > min && appointmentStartDate <= max;\n      }\n      if (result && recurrenceProcessor.isValidRecurrenceRule(recurrenceRule)) {\n        result = recurrenceProcessor.hasRecurrence({\n          rule: recurrenceRule,\n          exception: recurrenceException,\n          start: appointmentStartDate,\n          end: appointmentEndDate,\n          min: min,\n          max: max,\n          firstDayOfWeek: firstDayOfWeek,\n          appointmentTimezoneOffset: this.timeZoneCalculator.getOriginStartDateOffsetInMs(appointmentStartDate, appointment.startDateTimeZone, false)\n        });\n      }\n      return result;\n    }\n  }, {\n    key: \"filterLoadedAppointments\",\n    value: function filterLoadedAppointments(filterOptions, preparedItems) {\n      var filteredItems = this.filterPreparedItems(filterOptions, preparedItems);\n      return filteredItems.map(function (_ref2) {\n        var rawAppointment = _ref2.rawAppointment;\n        return rawAppointment;\n      });\n    }\n  }, {\n    key: \"filterPreparedItems\",\n    value: function filterPreparedItems(filterOptions, preparedItems) {\n      var combinedFilter = this._createAppointmentFilter(filterOptions);\n      return query(preparedItems).filter(combinedFilter).toArray();\n    }\n  }, {\n    key: \"filterAllDayAppointments\",\n    value: function filterAllDayAppointments(filterOptions, preparedItems) {\n      var combinedFilter = this._createAllDayAppointmentFilter(filterOptions);\n      return query(preparedItems).filter(combinedFilter).toArray().map(function (_ref3) {\n        var rawAppointment = _ref3.rawAppointment;\n        return rawAppointment;\n      });\n    }\n  }, {\n    key: \"strategyName\",\n    get: function get() {\n      return FilterStrategies.standard;\n    }\n  }, {\n    key: \"timeZoneCalculator\",\n    get: function get() {\n      return this.options.timeZoneCalculator;\n    }\n  }, {\n    key: \"viewStartDayHour\",\n    get: function get() {\n      return this.options.startDayHour;\n    }\n  }, {\n    key: \"viewEndDayHour\",\n    get: function get() {\n      return this.options.endDayHour;\n    }\n  }, {\n    key: \"timezone\",\n    get: function get() {\n      return this.options.timezone;\n    }\n  }, {\n    key: \"firstDayOfWeek\",\n    get: function get() {\n      return this.options.firstDayOfWeek;\n    }\n  }, {\n    key: \"showAllDayPanel\",\n    get: function get() {\n      return this.options.showAllDayPanel;\n    }\n  }, {\n    key: \"loadedResources\",\n    get: function get() {\n      return this._resolveOption(\"loadedResources\");\n    }\n  }, {\n    key: \"supportAllDayRow\",\n    get: function get() {\n      return this._resolveOption(\"supportAllDayRow\");\n    }\n  }, {\n    key: \"viewType\",\n    get: function get() {\n      return this._resolveOption(\"viewType\");\n    }\n  }, {\n    key: \"viewDirection\",\n    get: function get() {\n      return this._resolveOption(\"viewDirection\");\n    }\n  }, {\n    key: \"dateRange\",\n    get: function get() {\n      return this._resolveOption(\"dateRange\");\n    }\n  }, {\n    key: \"groupCount\",\n    get: function get() {\n      return this._resolveOption(\"groupCount\");\n    }\n  }, {\n    key: \"viewDataProvider\",\n    get: function get() {\n      return this._resolveOption(\"viewDataProvider\");\n    }\n  }, {\n    key: \"allDayPanelMode\",\n    get: function get() {\n      return this._resolveOption(\"allDayPanelMode\");\n    }\n  }]);\n  return AppointmentFilterBaseStrategy;\n}();\nexport var AppointmentFilterVirtualStrategy = /*#__PURE__*/function (_AppointmentFilterBas) {\n  _inherits(AppointmentFilterVirtualStrategy, _AppointmentFilterBas);\n  function AppointmentFilterVirtualStrategy() {\n    _classCallCheck(this, AppointmentFilterVirtualStrategy);\n    return _possibleConstructorReturn(this, _getPrototypeOf(AppointmentFilterVirtualStrategy).apply(this, arguments));\n  }\n  _createClass(AppointmentFilterVirtualStrategy, [{\n    key: \"filter\",\n    value: function filter(preparedItems) {\n      var _this5 = this;\n      var hourMs = toMs(\"hour\");\n      var isCalculateStartAndEndDayHour = calculateIsDateAndTimeView(this.viewType);\n      var checkIntersectViewport = isCalculateStartAndEndDayHour && \"horizontal\" === this.viewDirection;\n      var isAllDayWorkspace = !this.supportAllDayRow;\n      var showAllDayAppointments = this.showAllDayPanel || isAllDayWorkspace;\n      var endViewDate = this.viewDataProvider.getLastViewDateByEndDayHour(this.viewEndDayHour);\n      var filterOptions = [];\n      var groupsInfo = this.viewDataProvider.getCompletedGroupsInfo();\n      groupsInfo.forEach(function (item) {\n        var groupIndex = item.groupIndex;\n        var groupStartDate = item.startDate;\n        var groupEndDate = new Date(Math.min(item.endDate, endViewDate));\n        var startDayHour = isCalculateStartAndEndDayHour ? groupStartDate.getHours() : _this5.viewStartDayHour;\n        var endDayHour = isCalculateStartAndEndDayHour ? startDayHour + groupStartDate.getMinutes() / 60 + (groupEndDate - groupStartDate) / hourMs : _this5.viewEndDayHour;\n        var resources = _this5._getPrerenderFilterResources(groupIndex);\n        var hasAllDayPanel = _this5.viewDataProvider.hasGroupAllDayPanel(groupIndex);\n        var supportAllDayAppointment = isAllDayWorkspace || !!showAllDayAppointments && hasAllDayPanel;\n        filterOptions.push({\n          isVirtualScrolling: true,\n          startDayHour: startDayHour,\n          endDayHour: endDayHour,\n          viewStartDayHour: _this5.viewStartDayHour,\n          viewEndDayHour: _this5.viewEndDayHour,\n          min: groupStartDate,\n          max: groupEndDate,\n          supportMultiDayAppointments: isTimelineView(_this5.viewType),\n          allDay: supportAllDayAppointment,\n          resources: resources,\n          firstDayOfWeek: _this5.firstDayOfWeek,\n          checkIntersectViewport: checkIntersectViewport\n        });\n      });\n      return this.filterLoadedAppointments({\n        filterOptions: filterOptions,\n        groupCount: this.groupCount\n      }, preparedItems);\n    }\n  }, {\n    key: \"filterPreparedItems\",\n    value: function filterPreparedItems(_ref4, preparedItems) {\n      var _this6 = this;\n      var filterOptions = _ref4.filterOptions,\n        groupCount = _ref4.groupCount;\n      var combinedFilters = [];\n      var itemsToFilter = preparedItems;\n      var needPreFilter = groupCount > 0;\n      if (needPreFilter) {\n        itemsToFilter = itemsToFilter.filter(function (_ref5) {\n          var rawAppointment = _ref5.rawAppointment;\n          for (var i = 0; i < filterOptions.length; ++i) {\n            var resources = filterOptions[i].resources;\n            if (_this6._filterAppointmentByResources(rawAppointment, resources)) {\n              return true;\n            }\n          }\n        });\n      }\n      filterOptions.forEach(function (option) {\n        combinedFilters.length && combinedFilters.push(\"or\");\n        var filter = _this6._createAppointmentFilter(option);\n        combinedFilters.push(filter);\n      });\n      return query(itemsToFilter).filter(combinedFilters).toArray();\n    }\n  }, {\n    key: \"hasAllDayAppointments\",\n    value: function hasAllDayAppointments(adapters, preparedItems) {\n      return this.filterAllDayAppointments({\n        viewStartDayHour: this.viewStartDayHour,\n        viewEndDayHour: this.viewEndDayHour\n      }, preparedItems).length > 0;\n    }\n  }, {\n    key: \"_getPrerenderFilterResources\",\n    value: function _getPrerenderFilterResources(groupIndex) {\n      var cellGroup = this.viewDataProvider.getCellsGroup(groupIndex);\n      return getResourcesDataByGroups(this.loadedResources, this.resources, [cellGroup]);\n    }\n  }, {\n    key: \"strategyName\",\n    get: function get() {\n      return FilterStrategies.virtual;\n    }\n  }, {\n    key: \"resources\",\n    get: function get() {\n      return this.options.resources;\n    }\n  }]);\n  return AppointmentFilterVirtualStrategy;\n}(AppointmentFilterBaseStrategy);","map":null,"metadata":{},"sourceType":"module"}