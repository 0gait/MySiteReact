{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/overlay/ui.overlay.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getOuterWidth, getOuterHeight } from \"../../core/utils/size\";\nimport fx from \"../../animation/fx\";\nimport registerComponent from \"../../core/component_registrator\";\nimport devices from \"../../core/devices\";\nimport domAdapter from \"../../core/dom_adapter\";\nimport { getPublicElement } from \"../../core/element\";\nimport $ from \"../../core/renderer\";\nimport { EmptyTemplate } from \"../../core/templates/empty_template\";\nimport { noop } from \"../../core/utils/common\";\nimport { Deferred } from \"../../core/utils/deferred\";\nimport { contains, resetActiveElement } from \"../../core/utils/dom\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport readyCallbacks from \"../../core/utils/ready_callbacks\";\nimport { isFunction, isObject, isPromise, isWindow } from \"../../core/utils/type\";\nimport { changeCallback } from \"../../core/utils/view_port\";\nimport { getWindow, hasWindow } from \"../../core/utils/window\";\nimport errors from \"../../core/errors\";\nimport uiErrors from \"../widget/ui.errors\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport { move as dragEventMove } from \"../../events/drag\";\nimport pointerEvents from \"../../events/pointer\";\nimport { keyboard } from \"../../events/short\";\nimport { addNamespace, isCommandKeyPressed, normalizeKeyName } from \"../../events/utils/index\";\nimport { triggerHidingEvent, triggerResizeEvent, triggerShownEvent } from \"../../events/visibility_change\";\nimport { hideCallback as hideTopOverlayCallback } from \"../../mobile/hide_callback\";\nimport { tabbable } from \"../widget/selectors\";\nimport Widget from \"../widget/ui.widget\";\nimport browser from \"../../core/utils/browser\";\nimport * as zIndexPool from \"./z_index\";\nimport { OverlayPositionController, OVERLAY_POSITION_ALIASES } from \"./overlay_position_controller\";\nvar ready = readyCallbacks.add;\nvar window = getWindow();\nvar viewPortChanged = changeCallback;\nvar OVERLAY_CLASS = \"dx-overlay\";\nvar OVERLAY_WRAPPER_CLASS = \"dx-overlay-wrapper\";\nvar OVERLAY_CONTENT_CLASS = \"dx-overlay-content\";\nvar OVERLAY_SHADER_CLASS = \"dx-overlay-shader\";\nvar INNER_OVERLAY_CLASS = \"dx-inner-overlay\";\nvar INVISIBLE_STATE_CLASS = \"dx-state-invisible\";\nvar ANONYMOUS_TEMPLATE_NAME = \"content\";\nvar RTL_DIRECTION_CLASS = \"dx-rtl\";\nvar OVERLAY_STACK = [];\nvar PREVENT_SAFARI_SCROLLING_CLASS = \"dx-prevent-safari-scrolling\";\nvar TAB_KEY = \"tab\";\nready(function () {\n  eventsEngine.subscribeGlobal(domAdapter.getDocument(), pointerEvents.down, function (e) {\n    for (var i = OVERLAY_STACK.length - 1; i >= 0; i--) {\n      if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {\n        return;\n      }\n    }\n  });\n});\nvar Overlay = Widget.inherit({\n  _supportedKeys: function _supportedKeys() {\n    return extend(this.callBase(), {\n      escape: function escape() {\n        this.hide();\n      }\n    });\n  },\n  _getDefaultOptions: function _getDefaultOptions() {\n    var _this6 = this;\n    return extend(this.callBase(), {\n      activeStateEnabled: false,\n      visible: false,\n      deferRendering: true,\n      shading: true,\n      shadingColor: \"\",\n      wrapperAttr: {},\n      position: extend({}, OVERLAY_POSITION_ALIASES.center),\n      width: \"80vw\",\n      minWidth: null,\n      maxWidth: null,\n      height: \"80vh\",\n      minHeight: null,\n      maxHeight: null,\n      animation: {\n        show: {\n          type: \"pop\",\n          duration: 300,\n          from: {\n            scale: .55\n          }\n        },\n        hide: {\n          type: \"pop\",\n          duration: 300,\n          from: {\n            opacity: 1,\n            scale: 1\n          },\n          to: {\n            opacity: 0,\n            scale: .55\n          }\n        }\n      },\n      closeOnOutsideClick: false,\n      hideOnOutsideClick: false,\n      copyRootClassesToWrapper: false,\n      _ignoreCopyRootClassesToWrapperDeprecation: false,\n      _ignoreElementAttrDeprecation: false,\n      onShowing: null,\n      onShown: null,\n      onHiding: null,\n      onHidden: null,\n      contentTemplate: \"content\",\n      innerOverlay: false,\n      restorePosition: true,\n      container: void 0,\n      visualContainer: void 0,\n      hideTopOverlayHandler: function hideTopOverlayHandler() {\n        _this6.hide();\n      },\n      hideOnParentScroll: false,\n      onPositioned: null,\n      propagateOutsideClick: false,\n      ignoreChildEvents: true,\n      _checkParentVisibility: true,\n      _fixWrapperPosition: false\n    });\n  },\n  _defaultOptionsRules: function _defaultOptionsRules() {\n    return this.callBase().concat([{\n      device: function device() {\n        return !hasWindow();\n      },\n      options: {\n        width: null,\n        height: null,\n        animation: null,\n        _checkParentVisibility: false\n      }\n    }]);\n  },\n  _setOptionsByReference: function _setOptionsByReference() {\n    this.callBase();\n    extend(this._optionsByReference, {\n      animation: true\n    });\n  },\n  $wrapper: function $wrapper() {\n    return this._$wrapper;\n  },\n  _eventBindingTarget: function _eventBindingTarget() {\n    return this._$content;\n  },\n  _setDeprecatedOptions: function _setDeprecatedOptions() {\n    this.callBase();\n    extend(this._deprecatedOptions, {\n      closeOnOutsideClick: {\n        since: \"22.1\",\n        alias: \"hideOnOutsideClick\"\n      }\n    });\n  },\n  ctor: function ctor(element, options) {\n    this.callBase(element, options);\n    if (options) {\n      if (options.copyRootClassesToWrapper && !options._ignoreCopyRootClassesToWrapperDeprecation) {\n        this._logDeprecatedOptionWarning(\"copyRootClassesToWrapper\", {\n          since: \"21.2\",\n          message: 'Use the \"wrapperAttr\" option instead'\n        });\n      }\n      if (options.elementAttr && !options._ignoreElementAttrDeprecation) {\n        this._logDeprecatedOptionWarning(\"elementAttr\", {\n          since: \"21.2\",\n          message: 'Use the \"wrapperAttr\" option instead'\n        });\n      }\n    }\n  },\n  _init: function _init() {\n    var _this7 = this;\n    this.callBase();\n    this._initActions();\n    this._initHideOnOutsideClickHandler();\n    this._initTabTerminatorHandler();\n    this._customWrapperClass = null;\n    this._$wrapper = $(\"<div>\").addClass(OVERLAY_WRAPPER_CLASS);\n    this._$content = $(\"<div>\").addClass(OVERLAY_CONTENT_CLASS);\n    this._initInnerOverlayClass();\n    var $element = this.$element();\n    if (this.option(\"copyRootClassesToWrapper\")) {\n      this._$wrapper.addClass($element.attr(\"class\"));\n    }\n    $element.addClass(OVERLAY_CLASS);\n    this._$wrapper.attr(\"data-bind\", \"dxControlsDescendantBindings: true\");\n    this._toggleViewPortSubscription(true);\n    this._initHideTopOverlayHandler(this.option(\"hideTopOverlayHandler\"));\n    this._parentsScrollSubscriptionInfo = {\n      handler: function handler(e) {\n        _this7._hideOnParentsScrollHandler(e);\n      }\n    };\n    this.warnPositionAsFunction();\n  },\n  warnPositionAsFunction: function warnPositionAsFunction() {\n    if (isFunction(this.option(\"position\"))) {\n      errors.log(\"W0018\");\n    }\n  },\n  _initInnerOverlayClass: function _initInnerOverlayClass() {\n    this._$content.toggleClass(INNER_OVERLAY_CLASS, this.option(\"innerOverlay\"));\n  },\n  _initHideTopOverlayHandler: function _initHideTopOverlayHandler(handler) {\n    this._hideTopOverlayHandler = handler;\n  },\n  _getActionsList: function _getActionsList() {\n    return [\"onShowing\", \"onShown\", \"onHiding\", \"onHidden\", \"onPositioned\", \"onVisualPositionChanged\"];\n  },\n  _initActions: function _initActions() {\n    var _this8 = this;\n    this._actions = {};\n    var actions = this._getActionsList();\n    each(actions, function (_, action) {\n      _this8._actions[action] = _this8._createActionByOption(action, {\n        excludeValidators: [\"disabled\", \"readOnly\"]\n      }) || noop;\n    });\n  },\n  _initHideOnOutsideClickHandler: function _initHideOnOutsideClickHandler() {\n    var _this = this;\n    this._proxiedDocumentDownHandler = function () {\n      return _this._documentDownHandler.apply(_this, arguments);\n    };\n  },\n  _initMarkup: function _initMarkup() {\n    this.callBase();\n    this._renderWrapperAttributes();\n    this._initPositionController();\n  },\n  _documentDownHandler: function _documentDownHandler(e) {\n    if (this._showAnimationProcessing) {\n      this._stopAnimation();\n    }\n    var isAttachedTarget = $(window.document).is(e.target) || contains(window.document, e.target) || contains(window.document, e.target.getRootNode().host);\n    var isInnerOverlay = $(e.target).closest(\".\".concat(INNER_OVERLAY_CLASS)).length;\n    var outsideClick = isAttachedTarget && !isInnerOverlay && !(this._$content.is(e.target) || contains(this._$content.get(0), e.target));\n    if (outsideClick && this._shouldHideOnOutsideClick(e)) {\n      this._outsideClickHandler(e);\n    }\n    return this.option(\"propagateOutsideClick\");\n  },\n  _shouldHideOnOutsideClick: function _shouldHideOnOutsideClick(e) {\n    var _this$option = this.option(),\n      hideOnOutsideClick = _this$option.hideOnOutsideClick;\n    if (isFunction(hideOnOutsideClick)) {\n      return hideOnOutsideClick(e);\n    }\n    return hideOnOutsideClick;\n  },\n  _outsideClickHandler: function _outsideClickHandler(e) {\n    if (this.option(\"shading\")) {\n      e.preventDefault();\n    }\n    this.hide();\n  },\n  _getAnonymousTemplateName: function _getAnonymousTemplateName() {\n    return ANONYMOUS_TEMPLATE_NAME;\n  },\n  _initTemplates: function _initTemplates() {\n    this._templateManager.addDefaultTemplates({\n      content: new EmptyTemplate()\n    });\n    this.callBase();\n  },\n  _isTopOverlay: function _isTopOverlay() {\n    var overlayStack = this._overlayStack();\n    for (var i = overlayStack.length - 1; i >= 0; i--) {\n      var tabbableElements = overlayStack[i]._findTabbableBounds();\n      if (tabbableElements.first || tabbableElements.last) {\n        return overlayStack[i] === this;\n      }\n    }\n    return false;\n  },\n  _overlayStack: function _overlayStack() {\n    return OVERLAY_STACK;\n  },\n  _zIndexInitValue: function _zIndexInitValue() {\n    return Overlay.baseZIndex();\n  },\n  _toggleViewPortSubscription: function _toggleViewPortSubscription(toggle) {\n    var _this2 = this;\n    viewPortChanged.remove(this._viewPortChangeHandle);\n    if (toggle) {\n      this._viewPortChangeHandle = function () {\n        _this2._viewPortChangeHandler.apply(_this2, arguments);\n      };\n      viewPortChanged.add(this._viewPortChangeHandle);\n    }\n  },\n  _viewPortChangeHandler: function _viewPortChangeHandler() {\n    this._positionController.updateContainer(this.option(\"container\"));\n    this._refresh();\n  },\n  _renderWrapperAttributes: function _renderWrapperAttributes() {\n    var _this$option2 = this.option(),\n      wrapperAttr = _this$option2.wrapperAttr;\n    var attributes = extend({}, wrapperAttr);\n    var classNames = attributes.class;\n    delete attributes.class;\n    this.$wrapper().attr(attributes).removeClass(this._customWrapperClass).addClass(classNames);\n    this._customWrapperClass = classNames;\n  },\n  _renderVisibilityAnimate: function _renderVisibilityAnimate(visible) {\n    this._stopAnimation();\n    return visible ? this._show() : this._hide();\n  },\n  _getAnimationConfig: function _getAnimationConfig() {\n    return this._getOptionValue(\"animation\", this);\n  },\n  _animateShowing: function _animateShowing() {\n    var _this$_getAnimationCo,\n      _showAnimation$start,\n      _showAnimation$comple,\n      _this3 = this;\n    var animation = null !== (_this$_getAnimationCo = this._getAnimationConfig()) && void 0 !== _this$_getAnimationCo ? _this$_getAnimationCo : {};\n    var showAnimation = this._normalizeAnimation(animation.show, \"to\");\n    var startShowAnimation = null !== (_showAnimation$start = null === showAnimation || void 0 === showAnimation ? void 0 : showAnimation.start) && void 0 !== _showAnimation$start ? _showAnimation$start : noop;\n    var completeShowAnimation = null !== (_showAnimation$comple = null === showAnimation || void 0 === showAnimation ? void 0 : showAnimation.complete) && void 0 !== _showAnimation$comple ? _showAnimation$comple : noop;\n    this._animate(showAnimation, function () {\n      if (_this3._isAnimationPaused) {\n        return;\n      }\n      if (_this3.option(\"focusStateEnabled\")) {\n        eventsEngine.trigger(_this3._focusTarget(), \"focus\");\n      }\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      completeShowAnimation.call.apply(completeShowAnimation, [_this3].concat(args));\n      _this3._showAnimationProcessing = false;\n      _this3._isHidden = false;\n      _this3._actions.onShown();\n      _this3._toggleSafariScrolling();\n      _this3._showingDeferred.resolve();\n    }, function () {\n      if (_this3._isAnimationPaused) {\n        return;\n      }\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      startShowAnimation.call.apply(startShowAnimation, [_this3].concat(args));\n      _this3._showAnimationProcessing = true;\n    });\n  },\n  _processShowingHidingCancel: function _processShowingHidingCancel(cancelArg, applyFunction, cancelFunction) {\n    if (isPromise(cancelArg)) {\n      cancelArg.then(function (shouldCancel) {\n        if (shouldCancel) {\n          cancelFunction();\n        } else {\n          applyFunction();\n        }\n      }).catch(function () {\n        return applyFunction();\n      });\n    } else {\n      cancelArg ? cancelFunction() : applyFunction();\n    }\n  },\n  _show: function _show() {\n    var _this9 = this;\n    this._showingDeferred = new Deferred();\n    this._parentHidden = this._isParentHidden();\n    this._showingDeferred.done(function () {\n      delete _this9._parentHidden;\n    });\n    if (this._parentHidden) {\n      this._isHidden = true;\n      return this._showingDeferred.resolve();\n    }\n    if (this._currentVisible) {\n      return new Deferred().resolve().promise();\n    }\n    this._currentVisible = true;\n    if (this._isHidingActionCanceled) {\n      delete this._isHidingActionCanceled;\n      this._showingDeferred.reject();\n    } else {\n      var show = function show() {\n        _this9._stopAnimation();\n        _this9._toggleVisibility(true);\n        _this9._$content.css(\"visibility\", \"hidden\");\n        _this9._$content.toggleClass(INVISIBLE_STATE_CLASS, false);\n        _this9._updateZIndexStackPosition(true);\n        _this9._positionController.openingHandled();\n        _this9._renderContent();\n        var showingArgs = {\n          cancel: false\n        };\n        _this9._actions.onShowing(showingArgs);\n        _this9._processShowingHidingCancel(showingArgs.cancel, function () {\n          _this9._$content.css(\"visibility\", \"\");\n          _this9._renderVisibility(true);\n          _this9._animateShowing();\n        }, function () {\n          _this9._toggleVisibility(false);\n          _this9._$content.css(\"visibility\", \"\");\n          _this9._$content.toggleClass(INVISIBLE_STATE_CLASS, true);\n          _this9._isShowingActionCanceled = true;\n          _this9._moveFromContainer();\n          _this9.option(\"visible\", false);\n          _this9._showingDeferred.resolve();\n        });\n      };\n      if (this.option(\"templatesRenderAsynchronously\")) {\n        this._stopShowTimer();\n        this._asyncShowTimeout = setTimeout(show);\n      } else {\n        show();\n      }\n    }\n    return this._showingDeferred.promise();\n  },\n  _normalizeAnimation: function _normalizeAnimation(showHideConfig, direction) {\n    if (showHideConfig) {\n      showHideConfig = extend({\n        type: \"slide\",\n        skipElementInitialStyles: true\n      }, showHideConfig);\n      if (isObject(showHideConfig[direction])) {\n        extend(showHideConfig[direction], {\n          position: this._positionController.position\n        });\n      }\n    }\n    return showHideConfig;\n  },\n  _animateHiding: function _animateHiding() {\n    var _this$_getAnimationCo2,\n      _hideAnimation$start,\n      _hideAnimation$comple,\n      _this4 = this;\n    var animation = null !== (_this$_getAnimationCo2 = this._getAnimationConfig()) && void 0 !== _this$_getAnimationCo2 ? _this$_getAnimationCo2 : {};\n    var hideAnimation = this._normalizeAnimation(animation.hide, \"from\");\n    var startHideAnimation = null !== (_hideAnimation$start = null === hideAnimation || void 0 === hideAnimation ? void 0 : hideAnimation.start) && void 0 !== _hideAnimation$start ? _hideAnimation$start : noop;\n    var completeHideAnimation = null !== (_hideAnimation$comple = null === hideAnimation || void 0 === hideAnimation ? void 0 : hideAnimation.complete) && void 0 !== _hideAnimation$comple ? _hideAnimation$comple : noop;\n    this._animate(hideAnimation, function () {\n      var _this4$_actions;\n      _this4._$content.css(\"pointerEvents\", \"\");\n      _this4._renderVisibility(false);\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      completeHideAnimation.call.apply(completeHideAnimation, [_this4].concat(args));\n      _this4._hideAnimationProcessing = false;\n      null === (_this4$_actions = _this4._actions) || void 0 === _this4$_actions ? void 0 : _this4$_actions.onHidden();\n      _this4._hidingDeferred.resolve();\n    }, function () {\n      _this4._$content.css(\"pointerEvents\", \"none\");\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      startHideAnimation.call.apply(startHideAnimation, [_this4].concat(args));\n      _this4._hideAnimationProcessing = true;\n    });\n  },\n  _hide: function _hide() {\n    var _this10 = this;\n    if (!this._currentVisible) {\n      return new Deferred().resolve().promise();\n    }\n    this._currentVisible = false;\n    this._hidingDeferred = new Deferred();\n    var hidingArgs = {\n      cancel: false\n    };\n    if (this._isShowingActionCanceled) {\n      delete this._isShowingActionCanceled;\n      this._hidingDeferred.reject();\n    } else {\n      this._actions.onHiding(hidingArgs);\n      this._toggleSafariScrolling();\n      this._processShowingHidingCancel(hidingArgs.cancel, function () {\n        _this10._forceFocusLost();\n        _this10._toggleShading(false);\n        _this10._toggleSubscriptions(false);\n        _this10._stopShowTimer();\n        _this10._animateHiding();\n      }, function () {\n        _this10._isHidingActionCanceled = true;\n        _this10.option(\"visible\", true);\n        _this10._hidingDeferred.resolve();\n      });\n    }\n    return this._hidingDeferred.promise();\n  },\n  _forceFocusLost: function _forceFocusLost() {\n    var activeElement = domAdapter.getActiveElement();\n    var shouldResetActiveElement = !!this._$content.find(activeElement).length;\n    if (shouldResetActiveElement) {\n      resetActiveElement();\n    }\n  },\n  _animate: function _animate(animation, completeCallback, startCallback) {\n    if (animation) {\n      startCallback = startCallback || animation.start || noop;\n      fx.animate(this._$content, extend({}, animation, {\n        start: startCallback,\n        complete: completeCallback\n      }));\n    } else {\n      completeCallback();\n    }\n  },\n  _stopAnimation: function _stopAnimation() {\n    fx.stop(this._$content, true);\n  },\n  _renderVisibility: function _renderVisibility(visible) {\n    if (visible && this._isParentHidden()) {\n      return;\n    }\n    this._currentVisible = visible;\n    this._stopAnimation();\n    if (!visible) {\n      triggerHidingEvent(this._$content);\n    }\n    if (visible) {\n      this._checkContainerExists();\n      this._moveToContainer();\n      this._renderGeometry();\n      triggerShownEvent(this._$content);\n      triggerResizeEvent(this._$content);\n    } else {\n      this._toggleVisibility(visible);\n      this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible);\n      this._updateZIndexStackPosition(visible);\n      this._moveFromContainer();\n    }\n    this._toggleShading(visible);\n    this._toggleSubscriptions(visible);\n  },\n  _updateZIndexStackPosition: function _updateZIndexStackPosition(pushToStack) {\n    var overlayStack = this._overlayStack();\n    var index = overlayStack.indexOf(this);\n    if (pushToStack) {\n      if (-1 === index) {\n        this._zIndex = zIndexPool.create(this._zIndexInitValue());\n        overlayStack.push(this);\n      }\n      this._$wrapper.css(\"zIndex\", this._zIndex);\n      this._$content.css(\"zIndex\", this._zIndex);\n    } else if (-1 !== index) {\n      overlayStack.splice(index, 1);\n      zIndexPool.remove(this._zIndex);\n    }\n  },\n  _toggleShading: function _toggleShading(visible) {\n    this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option(\"shading\"));\n    this._$wrapper.css(\"backgroundColor\", this.option(\"shading\") ? this.option(\"shadingColor\") : \"\");\n    this._toggleTabTerminator(visible && this.option(\"shading\"));\n  },\n  _initTabTerminatorHandler: function _initTabTerminatorHandler() {\n    var _this5 = this;\n    this._proxiedTabTerminatorHandler = function () {\n      _this5._tabKeyHandler.apply(_this5, arguments);\n    };\n  },\n  _toggleTabTerminator: function _toggleTabTerminator(enabled) {\n    var eventName = addNamespace(\"keydown\", this.NAME);\n    if (enabled) {\n      eventsEngine.on(domAdapter.getDocument(), eventName, this._proxiedTabTerminatorHandler);\n    } else {\n      eventsEngine.off(domAdapter.getDocument(), eventName, this._proxiedTabTerminatorHandler);\n    }\n  },\n  _findTabbableBounds: function _findTabbableBounds() {\n    var $elements = this._$wrapper.find(\"*\");\n    var elementsCount = $elements.length - 1;\n    var result = {\n      first: null,\n      last: null\n    };\n    for (var i = 0; i <= elementsCount; i++) {\n      if (!result.first && $elements.eq(i).is(tabbable)) {\n        result.first = $elements.eq(i);\n      }\n      if (!result.last && $elements.eq(elementsCount - i).is(tabbable)) {\n        result.last = $elements.eq(elementsCount - i);\n      }\n      if (result.first && result.last) {\n        break;\n      }\n    }\n    return result;\n  },\n  _tabKeyHandler: function _tabKeyHandler(e) {\n    if (normalizeKeyName(e) !== TAB_KEY || !this._isTopOverlay()) {\n      return;\n    }\n    var tabbableElements = this._findTabbableBounds();\n    var $firstTabbable = tabbableElements.first;\n    var $lastTabbable = tabbableElements.last;\n    var isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0);\n    var isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0);\n    var isEmptyTabList = 0 === tabbableElements.length;\n    var isOutsideTarget = !contains(this._$wrapper.get(0), e.target);\n    if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {\n      e.preventDefault();\n      var $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;\n      eventsEngine.trigger($focusElement, \"focusin\");\n      eventsEngine.trigger($focusElement, \"focus\");\n    }\n  },\n  _toggleSubscriptions: function _toggleSubscriptions(enabled) {\n    if (hasWindow()) {\n      this._toggleHideTopOverlayCallback(enabled);\n      this._toggleHideOnParentsScrollSubscription(enabled);\n    }\n  },\n  _toggleHideTopOverlayCallback: function _toggleHideTopOverlayCallback(subscribe) {\n    if (!this._hideTopOverlayHandler) {\n      return;\n    }\n    if (subscribe) {\n      hideTopOverlayCallback.add(this._hideTopOverlayHandler);\n    } else {\n      hideTopOverlayCallback.remove(this._hideTopOverlayHandler);\n    }\n  },\n  _toggleHideOnParentsScrollSubscription: function _toggleHideOnParentsScrollSubscription(needSubscribe) {\n    var _this$_parentsScrollS;\n    var scrollEvent = addNamespace(\"scroll\", this.NAME);\n    var _ref = null !== (_this$_parentsScrollS = this._parentsScrollSubscriptionInfo) && void 0 !== _this$_parentsScrollS ? _this$_parentsScrollS : {},\n      prevTargets = _ref.prevTargets,\n      handler = _ref.handler;\n    eventsEngine.off(prevTargets, scrollEvent, handler);\n    var closeOnScroll = this.option(\"hideOnParentScroll\");\n    if (needSubscribe && closeOnScroll) {\n      var $parents = this._hideOnParentScrollTarget().parents();\n      if (\"desktop\" === devices.real().deviceType) {\n        $parents = $parents.add(window);\n      }\n      eventsEngine.on($parents, scrollEvent, handler);\n      this._parentsScrollSubscriptionInfo.prevTargets = $parents;\n    }\n  },\n  _hideOnParentsScrollHandler: function _hideOnParentsScrollHandler(e) {\n    var closeHandled = false;\n    var closeOnScroll = this.option(\"hideOnParentScroll\");\n    if (isFunction(closeOnScroll)) {\n      closeHandled = closeOnScroll(e);\n    }\n    if (!closeHandled && !this._showAnimationProcessing) {\n      this.hide();\n    }\n  },\n  _hideOnParentScrollTarget: function _hideOnParentScrollTarget() {\n    return this._$wrapper;\n  },\n  _render: function _render() {\n    this.callBase();\n    this._appendContentToElement();\n    this._renderVisibilityAnimate(this.option(\"visible\"));\n  },\n  _appendContentToElement: function _appendContentToElement() {\n    if (!this._$content.parent().is(this.$element())) {\n      this._$content.appendTo(this.$element());\n    }\n  },\n  _renderContent: function _renderContent() {\n    var shouldDeferRendering = !this._currentVisible && this.option(\"deferRendering\");\n    var isParentHidden = this.option(\"visible\") && this._isParentHidden();\n    if (isParentHidden) {\n      this._isHidden = true;\n      return;\n    }\n    if (this._contentAlreadyRendered || shouldDeferRendering) {\n      return;\n    }\n    this._contentAlreadyRendered = true;\n    this._appendContentToElement();\n    this.callBase();\n  },\n  _isParentHidden: function _isParentHidden() {\n    if (!this.option(\"_checkParentVisibility\")) {\n      return false;\n    }\n    if (void 0 !== this._parentHidden) {\n      return this._parentHidden;\n    }\n    var $parent = this.$element().parent();\n    if ($parent.is(\":visible\")) {\n      return false;\n    }\n    var isHidden = false;\n    $parent.add($parent.parents()).each(function () {\n      var $element = $(this);\n      if (\"none\" === $element.css(\"display\")) {\n        isHidden = true;\n        return false;\n      }\n    });\n    return isHidden || !domAdapter.getBody().contains($parent.get(0));\n  },\n  _renderContentImpl: function _renderContentImpl() {\n    var _this11 = this;\n    var whenContentRendered = new Deferred();\n    var contentTemplateOption = this.option(\"contentTemplate\");\n    var contentTemplate = this._getTemplate(contentTemplateOption);\n    var transclude = this._templateManager.anonymousTemplateName === contentTemplateOption;\n    contentTemplate && contentTemplate.render({\n      container: getPublicElement(this.$content()),\n      noModel: true,\n      transclude: transclude,\n      onRendered: function onRendered() {\n        whenContentRendered.resolve();\n        if (_this11.option(\"templatesRenderAsynchronously\")) {\n          _this11._dimensionChanged();\n        }\n      }\n    });\n    this._renderScrollTerminator();\n    whenContentRendered.done(function () {\n      if (_this11.option(\"visible\")) {\n        _this11._moveToContainer();\n      }\n    });\n    return whenContentRendered.promise();\n  },\n  _getPositionControllerConfig: function _getPositionControllerConfig() {\n    var _this$option3 = this.option(),\n      container = _this$option3.container,\n      visualContainer = _this$option3.visualContainer,\n      _fixWrapperPosition = _this$option3._fixWrapperPosition,\n      restorePosition = _this$option3.restorePosition;\n    return {\n      container: container,\n      visualContainer: visualContainer,\n      $root: this.$element(),\n      $content: this._$content,\n      $wrapper: this._$wrapper,\n      onPositioned: this._actions.onPositioned,\n      onVisualPositionChanged: this._actions.onVisualPositionChanged,\n      restorePosition: restorePosition,\n      _fixWrapperPosition: _fixWrapperPosition\n    };\n  },\n  _initPositionController: function _initPositionController() {\n    this._positionController = new OverlayPositionController(this._getPositionControllerConfig());\n  },\n  _renderScrollTerminator: function _renderScrollTerminator() {\n    var $scrollTerminator = this._$wrapper;\n    var terminatorEventName = addNamespace(dragEventMove, this.NAME);\n    eventsEngine.off($scrollTerminator, terminatorEventName);\n    eventsEngine.on($scrollTerminator, terminatorEventName, {\n      validate: function validate() {\n        return true;\n      },\n      getDirection: function getDirection() {\n        return \"both\";\n      },\n      _toggleGestureCover: function _toggleGestureCover(toggle) {\n        if (!toggle) {\n          this._toggleGestureCoverImpl(toggle);\n        }\n      },\n      _clearSelection: noop,\n      isNative: true\n    }, function (e) {\n      var originalEvent = e.originalEvent.originalEvent;\n      var _ref2 = originalEvent || {},\n        type = _ref2.type;\n      var isWheel = \"wheel\" === type;\n      var isMouseMove = \"mousemove\" === type;\n      var isScrollByWheel = isWheel && !isCommandKeyPressed(e);\n      e._cancelPreventDefault = true;\n      if (originalEvent && false !== e.cancelable && (!isMouseMove && !isWheel || isScrollByWheel)) {\n        e.preventDefault();\n      }\n    });\n  },\n  _moveFromContainer: function _moveFromContainer() {\n    this._$content.appendTo(this.$element());\n    this._$wrapper.detach();\n  },\n  _checkContainerExists: function _checkContainerExists() {\n    var $wrapperContainer = this._positionController.$container;\n    var containerExists = $wrapperContainer.length > 0;\n    if (!containerExists) {\n      uiErrors.log(\"W1021\", this.NAME);\n    }\n  },\n  _moveToContainer: function _moveToContainer() {\n    var $wrapperContainer = this._positionController.$container;\n    this._$wrapper.appendTo($wrapperContainer);\n    this._$content.appendTo(this._$wrapper);\n  },\n  _renderGeometry: function _renderGeometry(options) {\n    var _this$option4 = this.option(),\n      visible = _this$option4.visible;\n    if (visible && hasWindow()) {\n      this._stopAnimation();\n      this._renderGeometryImpl();\n    }\n  },\n  _renderGeometryImpl: function _renderGeometryImpl() {\n    this._positionController.updatePosition(this._getOptionValue(\"position\"));\n    this._renderWrapper();\n    this._renderDimensions();\n    this._renderPosition();\n  },\n  _renderPosition: function _renderPosition() {\n    this._positionController.positionContent();\n  },\n  _isAllWindowCovered: function _isAllWindowCovered() {\n    return isWindow(this._positionController.$visualContainer.get(0)) && this.option(\"shading\");\n  },\n  _toggleSafariScrolling: function _toggleSafariScrolling() {\n    var visible = this.option(\"visible\");\n    var $body = $(domAdapter.getBody());\n    var isIosSafari = \"ios\" === devices.real().platform && browser.safari;\n    var isAllWindowCovered = this._isAllWindowCovered();\n    var isScrollingPrevented = $body.hasClass(PREVENT_SAFARI_SCROLLING_CLASS);\n    var shouldPreventScrolling = !isScrollingPrevented && visible && isAllWindowCovered;\n    var shouldEnableScrolling = isScrollingPrevented && (!visible || !isAllWindowCovered || this._disposed);\n    if (isIosSafari) {\n      if (shouldEnableScrolling) {\n        $body.removeClass(PREVENT_SAFARI_SCROLLING_CLASS);\n        window.scrollTo(0, this._cachedBodyScrollTop);\n        this._cachedBodyScrollTop = void 0;\n      } else if (shouldPreventScrolling) {\n        this._cachedBodyScrollTop = window.pageYOffset;\n        $body.addClass(PREVENT_SAFARI_SCROLLING_CLASS);\n      }\n    }\n  },\n  _renderWrapper: function _renderWrapper() {\n    this._positionController.styleWrapperPosition();\n    this._renderWrapperDimensions();\n    this._positionController.positionWrapper();\n  },\n  _renderWrapperDimensions: function _renderWrapperDimensions() {\n    var $visualContainer = this._positionController.$visualContainer;\n    var documentElement = domAdapter.getDocumentElement();\n    var isVisualContainerWindow = isWindow($visualContainer.get(0));\n    var wrapperWidth = isVisualContainerWindow ? documentElement.clientWidth : getOuterWidth($visualContainer);\n    var wrapperHeight = isVisualContainerWindow ? window.innerHeight : getOuterHeight($visualContainer);\n    this._$wrapper.css({\n      width: wrapperWidth,\n      height: wrapperHeight\n    });\n  },\n  _renderDimensions: function _renderDimensions() {\n    var content = this._$content.get(0);\n    this._$content.css({\n      minWidth: this._getOptionValue(\"minWidth\", content),\n      maxWidth: this._getOptionValue(\"maxWidth\", content),\n      minHeight: this._getOptionValue(\"minHeight\", content),\n      maxHeight: this._getOptionValue(\"maxHeight\", content),\n      width: this._getOptionValue(\"width\", content),\n      height: this._getOptionValue(\"height\", content)\n    });\n  },\n  _focusTarget: function _focusTarget() {\n    return this._$content;\n  },\n  _attachKeyboardEvents: function _attachKeyboardEvents() {\n    var _this12 = this;\n    this._keyboardListenerId = keyboard.on(this._$content, null, function (opts) {\n      return _this12._keyboardHandler(opts);\n    });\n  },\n  _keyboardHandler: function _keyboardHandler(options) {\n    var e = options.originalEvent;\n    var $target = $(e.target);\n    if ($target.is(this._$content) || !this.option(\"ignoreChildEvents\")) {\n      this.callBase.apply(this, arguments);\n    }\n  },\n  _isVisible: function _isVisible() {\n    return this.option(\"visible\");\n  },\n  _visibilityChanged: function _visibilityChanged(visible) {\n    if (visible) {\n      if (this.option(\"visible\")) {\n        this._renderVisibilityAnimate(visible);\n      }\n    } else {\n      this._renderVisibilityAnimate(visible);\n    }\n  },\n  _dimensionChanged: function _dimensionChanged() {\n    this._renderGeometry();\n  },\n  _clean: function _clean() {\n    var options = this.option();\n    if (!this._contentAlreadyRendered && !options.isRenovated) {\n      this.$content().empty();\n    }\n    this._renderVisibility(false);\n    this._stopShowTimer();\n    this._cleanFocusState();\n  },\n  _stopShowTimer: function _stopShowTimer() {\n    if (this._asyncShowTimeout) {\n      clearTimeout(this._asyncShowTimeout);\n    }\n    this._asyncShowTimeout = null;\n  },\n  _dispose: function _dispose() {\n    fx.stop(this._$content, false);\n    clearTimeout(this._deferShowTimer);\n    this._toggleViewPortSubscription(false);\n    this._toggleSubscriptions(false);\n    this._updateZIndexStackPosition(false);\n    this._toggleTabTerminator(false);\n    this._actions = null;\n    this._parentsScrollSubscriptionInfo = null;\n    this.callBase();\n    this._toggleSafariScrolling();\n    this.option(\"visible\") && zIndexPool.remove(this._zIndex);\n    this._$wrapper.remove();\n    this._$content.remove();\n  },\n  _toggleRTLDirection: function _toggleRTLDirection(rtl) {\n    this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl);\n  },\n  _optionChanged: function _optionChanged(args) {\n    var _this13 = this;\n    var value = args.value;\n    if (this._getActionsList().includes(args.name)) {\n      this._initActions();\n      return;\n    }\n    switch (args.name) {\n      case \"animation\":\n        break;\n      case \"shading\":\n        this._toggleShading(this.option(\"visible\"));\n        this._toggleSafariScrolling();\n        break;\n      case \"shadingColor\":\n        this._toggleShading(this.option(\"visible\"));\n        break;\n      case \"width\":\n      case \"height\":\n        this._renderGeometry();\n        break;\n      case \"minWidth\":\n      case \"maxWidth\":\n      case \"minHeight\":\n      case \"maxHeight\":\n        this._renderGeometry();\n        break;\n      case \"position\":\n        this._positionController.updatePosition(this.option(\"position\"));\n        this._positionController.restorePositionOnNextRender(true);\n        this._renderGeometry();\n        this._toggleSafariScrolling();\n        break;\n      case \"visible\":\n        this._renderVisibilityAnimate(value).done(function () {\n          var _this$_animateDeferre;\n          return null === (_this$_animateDeferre = _this13._animateDeferred) || void 0 === _this$_animateDeferre ? void 0 : _this$_animateDeferre.resolveWith(_this13);\n        }).fail(function () {\n          var _this$_animateDeferre2;\n          return null === (_this$_animateDeferre2 = _this13._animateDeferred) || void 0 === _this$_animateDeferre2 ? void 0 : _this$_animateDeferre2.reject();\n        });\n        break;\n      case \"container\":\n        this._positionController.updateContainer(value);\n        this._invalidate();\n        this._toggleSafariScrolling();\n        break;\n      case \"visualContainer\":\n        this._positionController.updateVisualContainer(value);\n        this._renderWrapper();\n        this._toggleSafariScrolling();\n        break;\n      case \"innerOverlay\":\n        this._initInnerOverlayClass();\n        break;\n      case \"deferRendering\":\n      case \"contentTemplate\":\n        this._contentAlreadyRendered = false;\n        this._clean();\n        this._invalidate();\n        break;\n      case \"hideTopOverlayHandler\":\n        this._toggleHideTopOverlayCallback(false);\n        this._initHideTopOverlayHandler(args.value);\n        this._toggleHideTopOverlayCallback(this.option(\"visible\"));\n        break;\n      case \"hideOnParentScroll\":\n        this._toggleHideOnParentsScrollSubscription(this.option(\"visible\"));\n        break;\n      case \"closeOnOutsideClick\":\n      case \"hideOnOutsideClick\":\n      case \"propagateOutsideClick\":\n        break;\n      case \"rtlEnabled\":\n        this._contentAlreadyRendered = false;\n        this.callBase(args);\n        break;\n      case \"_fixWrapperPosition\":\n        this._positionController.fixWrapperPosition = value;\n        break;\n      case \"wrapperAttr\":\n        this._renderWrapperAttributes();\n        break;\n      case \"restorePosition\":\n        this._positionController.restorePosition = args.value;\n        break;\n      default:\n        this.callBase(args);\n    }\n  },\n  toggle: function toggle(showing) {\n    var _this14 = this;\n    showing = void 0 === showing ? !this.option(\"visible\") : showing;\n    var result = new Deferred();\n    if (showing === this.option(\"visible\")) {\n      return result.resolveWith(this, [showing]).promise();\n    }\n    var animateDeferred = new Deferred();\n    this._animateDeferred = animateDeferred;\n    this.option(\"visible\", showing);\n    animateDeferred.promise().done(function () {\n      delete _this14._animateDeferred;\n      result.resolveWith(_this14, [_this14.option(\"visible\")]);\n    }).fail(function () {\n      delete _this14._animateDeferred;\n      result.reject();\n    });\n    return result.promise();\n  },\n  $content: function $content() {\n    return this._$content;\n  },\n  show: function show() {\n    return this.toggle(true);\n  },\n  hide: function hide() {\n    return this.toggle(false);\n  },\n  content: function content() {\n    return getPublicElement(this._$content);\n  },\n  repaint: function repaint() {\n    if (this._contentAlreadyRendered) {\n      this._positionController.restorePositionOnNextRender(true);\n      this._renderGeometry({\n        forceStopAnimation: true\n      });\n      triggerResizeEvent(this._$content);\n    } else {\n      this.callBase();\n    }\n  }\n});\nOverlay.baseZIndex = function (zIndex) {\n  return zIndexPool.base(zIndex);\n};\nregisterComponent(\"dxOverlay\", Overlay);\nexport default Overlay;","map":null,"metadata":{},"sourceType":"module"}