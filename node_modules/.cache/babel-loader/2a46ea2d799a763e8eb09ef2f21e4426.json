{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n/**\r\n * DevExtreme (esm/core/utils/array.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined } from \"./type\";\nimport { orderEach } from \"./object\";\nimport config from \"../config\";\nfunction createOccurrenceMap(array) {\n  return array.reduce(function (map, value) {\n    var _map$value;\n    map[value] = (null !== (_map$value = map[value]) && void 0 !== _map$value ? _map$value : 0) + 1;\n    return map;\n  }, {});\n}\nexport var wrapToArray = function wrapToArray(item) {\n  return Array.isArray(item) ? item : [item];\n};\nexport var getUniqueValues = function getUniqueValues(values) {\n  return _toConsumableArray(new Set(values));\n};\nexport var getIntersection = function getIntersection(firstArray, secondArray) {\n  var secondArrayMap = createOccurrenceMap(secondArray);\n  return firstArray.filter(function (value) {\n    return secondArrayMap[value]--;\n  });\n};\nexport var removeDuplicates = function removeDuplicates() {\n  var from = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];\n  var toRemove = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];\n  var toRemoveMap = createOccurrenceMap(toRemove);\n  return from.filter(function (value) {\n    return !toRemoveMap[value]--;\n  });\n};\nexport var normalizeIndexes = function normalizeIndexes(items, indexPropName, currentItem, needIndexCallback) {\n  var indexedItems = {};\n  var _config = config(),\n    useLegacyVisibleIndex = _config.useLegacyVisibleIndex;\n  var currentIndex = 0;\n  var shouldUpdateIndex = function shouldUpdateIndex(item) {\n    return !isDefined(item[indexPropName]) && (!needIndexCallback || needIndexCallback(item));\n  };\n  items.forEach(function (item) {\n    var index = item[indexPropName];\n    if (index >= 0) {\n      indexedItems[index] = indexedItems[index] || [];\n      if (item === currentItem) {\n        indexedItems[index].unshift(item);\n      } else {\n        indexedItems[index].push(item);\n      }\n    } else {\n      item[indexPropName] = void 0;\n    }\n  });\n  if (!useLegacyVisibleIndex) {\n    items.forEach(function (item) {\n      if (shouldUpdateIndex(item)) {\n        while (indexedItems[currentIndex]) {\n          currentIndex++;\n        }\n        indexedItems[currentIndex] = [item];\n        currentIndex++;\n      }\n    });\n  }\n  currentIndex = 0;\n  orderEach(indexedItems, function (index, items) {\n    items.forEach(function (item) {\n      if (index >= 0) {\n        item[indexPropName] = currentIndex++;\n      }\n    });\n  });\n  if (useLegacyVisibleIndex) {\n    items.forEach(function (item) {\n      if (shouldUpdateIndex(item)) {\n        item[indexPropName] = currentIndex++;\n      }\n    });\n  }\n};\nexport var groupBy = function groupBy(array, getGroupName) {\n  return array.reduce(function (groupedResult, item) {\n    var _groupedResult$groupN;\n    var groupName = getGroupName(item);\n    groupedResult[groupName] = null !== (_groupedResult$groupN = groupedResult[groupName]) && void 0 !== _groupedResult$groupN ? _groupedResult$groupN : [];\n    groupedResult[groupName].push(item);\n    return groupedResult;\n  }, {});\n};","map":null,"metadata":{},"sourceType":"module"}