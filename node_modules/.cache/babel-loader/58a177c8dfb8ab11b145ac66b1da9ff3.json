{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/helpers/range_data_calculator.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { unique, getAddFunction, getLog } from \"../../core/utils\";\nimport { isDefined, isObject } from \"../../../core/utils/type\";\nimport { noop } from \"../../../core/utils/common\";\nvar DISCRETE = \"discrete\";\nvar abs = Math.abs,\n  floor = Math.floor,\n  ceil = Math.ceil,\n  min = Math.min;\nfunction continuousRangeCalculator(range, minValue, maxValue) {\n  range.min = range.min < minValue ? range.min : minValue;\n  range.max = range.max > maxValue ? range.max : maxValue;\n}\nfunction createGetLogFunction(axisType, axis) {\n  if (\"logarithmic\" !== axisType) {\n    return null;\n  }\n  var base = axis.getOptions().logarithmBase;\n  return function (value) {\n    var log = getLog(abs(value), base);\n    var round = log < 0 ? floor : ceil;\n    return round(log);\n  };\n}\nfunction getRangeCalculator(axisType, axis, getLog) {\n  var rangeCalculator = continuousRangeCalculator;\n  if (axisType === DISCRETE) {\n    rangeCalculator = function rangeCalculator(range, minValue, maxValue) {\n      if (minValue !== maxValue) {\n        range.categories.push(maxValue);\n      }\n      range.categories.push(minValue);\n    };\n  } else if (axis) {\n    rangeCalculator = function rangeCalculator(range, value) {\n      var interval = axis.calculateInterval(value, range.prevValue);\n      var minInterval = range.interval;\n      range.interval = (minInterval < interval ? minInterval : interval) || minInterval;\n      range.prevValue = value;\n      continuousRangeCalculator(range, value, value);\n    };\n  }\n  if (getLog) {\n    return function (range, minValue, maxValue) {\n      var minArgs = [];\n      rangeCalculator(range, minValue, maxValue);\n      0 !== minValue && minArgs.push(getLog(minValue));\n      0 !== maxValue && minArgs.push(getLog(maxValue));\n      var linearThreshold = min.apply(null, minArgs);\n      range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold;\n    };\n  }\n  return rangeCalculator;\n}\nfunction getInitialRange(axisType, dataType, firstValue) {\n  var range = {\n    axisType: axisType,\n    dataType: dataType\n  };\n  if (axisType === DISCRETE) {\n    range.categories = [];\n  } else {\n    range.min = isObject(firstValue) ? firstValue.min : firstValue;\n    range.max = isObject(firstValue) ? firstValue.max : firstValue;\n  }\n  return range;\n}\nfunction processCategories(range) {\n  if (range.categories) {\n    range.categories = unique(range.categories);\n  }\n  return range;\n}\nfunction getValueForArgument(point, extraPoint, x, range) {\n  if (extraPoint && isDefined(extraPoint.value)) {\n    var y1 = point.value;\n    var y2 = extraPoint.value;\n    var x1 = point.argument;\n    var x2 = extraPoint.argument;\n    var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();\n    return \"datetime\" === range.dataType ? new Date(r) : r;\n  } else {\n    return point.value;\n  }\n}\nfunction calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {\n  var value = getValueForArgument(point, prevPoint, bound, range);\n  rangeCalculator(range, value, value);\n}\nfunction isLineSeries(series) {\n  return series.type.toLowerCase().indexOf(\"line\") >= 0 || series.type.toLowerCase().indexOf(\"area\") >= 0;\n}\nfunction getViewportReducer(series) {\n  var rangeCalculator = getRangeCalculator(series.valueAxisType);\n  var argumentAxis = series.getArgumentAxis();\n  var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};\n  var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : noop;\n  if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {\n    var range = series.getArgumentAxis().getTranslator().getBusinessRange();\n    var add = getAddFunction(range, false);\n    var interval = range.interval;\n    if (isFinite(interval) && isDefined(viewport.startValue) && isDefined(viewport.endValue)) {\n      viewport.startValue = add(viewport.startValue, interval, -1);\n      viewport.endValue = add(viewport.endValue, interval);\n    }\n  }\n  var viewportFilter = getViewPortFilter(viewport);\n  return function (range, point, index, points) {\n    var argument = point.argument;\n    if (!point.hasValue()) {\n      return range;\n    }\n    if (viewportFilter(argument)) {\n      if (!range.startCalc) {\n        range.startCalc = true;\n        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);\n      }\n      rangeCalculator(range, point.getMinValue(), point.getMaxValue());\n    } else if (!viewport.categories && isDefined(viewport.startValue) && argument > viewport.startValue) {\n      if (!range.startCalc) {\n        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);\n      }\n      range.endCalc = true;\n      calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue);\n    }\n    return range;\n  };\n}\nfunction getViewPortFilter(viewport) {\n  if (viewport.categories) {\n    var dictionary = viewport.categories.reduce(function (result, category) {\n      result[category.valueOf()] = true;\n      return result;\n    }, {});\n    return function (argument) {\n      return isDefined(argument) && dictionary[argument.valueOf()];\n    };\n  }\n  if (!isDefined(viewport.startValue) && !isDefined(viewport.endValue)) {\n    return function () {\n      return true;\n    };\n  }\n  if (!isDefined(viewport.endValue)) {\n    return function (argument) {\n      return argument >= viewport.startValue;\n    };\n  }\n  if (!isDefined(viewport.startValue)) {\n    return function (argument) {\n      return argument <= viewport.endValue;\n    };\n  }\n  return function (argument) {\n    return argument >= viewport.startValue && argument <= viewport.endValue;\n  };\n}\nexport default {\n  getViewPortFilter: getViewPortFilter,\n  getArgumentRange: function getArgumentRange(series) {\n    var data = series._data || [];\n    var range = {};\n    if (data.length) {\n      if (series.argumentAxisType === DISCRETE) {\n        range = {\n          categories: data.map(function (item) {\n            return item.argument;\n          })\n        };\n      } else {\n        var interval;\n        if (data.length > 1) {\n          var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);\n          var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);\n          interval = min(i1, i2);\n        }\n        range = {\n          min: data[0].argument,\n          max: data[data.length - 1].argument,\n          interval: interval\n        };\n      }\n    }\n    return processCategories(range);\n  },\n  getRangeData: function getRangeData(series) {\n    var points = series.getPoints();\n    var useAggregation = series.useAggregation();\n    var argumentAxis = series.getArgumentAxis();\n    var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && argumentAxis, createGetLogFunction(series.argumentAxisType, argumentAxis));\n    var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));\n    var viewportReducer = getViewportReducer(series);\n    var range = points.reduce(function (range, point, index, points) {\n      var argument = point.argument;\n      if (!point.isArgumentCorrect()) {\n        return range;\n      }\n      argumentCalculator(range.arg, argument, argument);\n      if (point.hasValue()) {\n        valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());\n        viewportReducer(range.viewport, point, index, points);\n      }\n      return range;\n    }, {\n      arg: getInitialRange(series.argumentAxisType, series.argumentType, null !== argumentAxis && void 0 !== argumentAxis && argumentAxis.aggregatedPointBetweenTicks() ? void 0 : series.getArgumentRangeInitialValue()),\n      val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0),\n      viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0)\n    });\n    if (useAggregation) {\n      var argumentRange = this.getArgumentRange(series);\n      if (series.argumentAxisType === DISCRETE) {\n        range.arg = argumentRange;\n      } else {\n        var viewport = argumentAxis.getViewport();\n        if (isDefined(viewport.startValue) || isDefined(viewport.length)) {\n          argumentCalculator(range.arg, argumentRange.min, argumentRange.min);\n        }\n        if (isDefined(viewport.endValue) || isDefined(viewport.length) && isDefined(viewport.startValue)) {\n          argumentCalculator(range.arg, argumentRange.max, argumentRange.max);\n        }\n      }\n    }\n    processCategories(range.arg);\n    processCategories(range.val);\n    return range;\n  },\n  getViewport: function getViewport(series) {\n    var points = series.getPoints();\n    var range;\n    var reducer = getViewportReducer(series);\n    range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0);\n    points.some(function (point, index) {\n      reducer(range, point, index, points);\n      return range.endCalc;\n    });\n    return range;\n  },\n  getPointsInViewPort: function getPointsInViewPort(series) {\n    var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});\n    var valueViewPort = series.getValueAxis().visualRange() || {};\n    var valueViewPortFilter = getViewPortFilter(valueViewPort);\n    var points = series.getPoints();\n    var addValue = function addValue(values, point, isEdge) {\n      var minValue = point.getMinValue();\n      var maxValue = point.getMaxValue();\n      var isMinValueInViewPort = valueViewPortFilter(minValue);\n      var isMaxValueInViewPort = valueViewPortFilter(maxValue);\n      if (isMinValueInViewPort) {\n        values.push(minValue);\n      }\n      if (maxValue !== minValue && isMaxValueInViewPort) {\n        values.push(maxValue);\n      }\n      if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {\n        if (!values.length) {\n          values.push(valueViewPort.startValue);\n        } else {\n          values.push(valueViewPort.endValue);\n        }\n      }\n    };\n    var addEdgePoints = isLineSeries(series) ? function (result, points, index) {\n      var point = points[index];\n      var prevPoint = points[index - 1];\n      var nextPoint = points[index + 1];\n      if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {\n        addValue(result[1], point, true);\n      }\n      if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {\n        addValue(result[1], point, true);\n      }\n    } : noop;\n    return points.reduce(function (result, point, index) {\n      if (argumentViewPortFilter(point.argument)) {\n        addValue(result[0], point);\n      } else {\n        addEdgePoints(result, points, index);\n      }\n      return result;\n    }, [[], []]);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}