{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\tiriq\\\\Documents\\\\Tiago\\\\MyThings\\\\MyProjects\\\\site\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n/**\r\n * DevExtreme (esm/ui/scheduler/appointments/rendering_strategies/strategy_vertical.js)\r\n * Version: 22.2.4\r\n * Build date: Thu Jan 19 2023\r\n *\r\n * Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport BaseAppointmentsStrategy from \"./strategy.base\";\nimport { extend } from \"../../../../core/utils/extend\";\nimport { isNumeric } from \"../../../../core/utils/type\";\nimport dateUtils from \"../../../../core/utils/date\";\nimport timeZoneUtils from \"../../utils.timeZone\";\nimport { ExpressionUtils } from \"../../expressionUtils\";\nimport { createAppointmentAdapter } from \"../../appointmentAdapter\";\nimport getSkippedHoursInRange from \"../../../../renovation/ui/scheduler/view_model/appointments/utils/getSkippedHoursInRange\";\nimport { getAppointmentTakesAllDay } from \"../../../../renovation/ui/scheduler/appointment/utils/getAppointmentTakesAllDay\";\nimport { roundFloatPart } from \"../../../../core/utils/math\";\nvar ALLDAY_APPOINTMENT_MIN_VERTICAL_OFFSET = 5;\nvar ALLDAY_APPOINTMENT_MAX_VERTICAL_OFFSET = 20;\nvar toMs = dateUtils.dateToMilliseconds;\nvar VerticalRenderingStrategy = /*#__PURE__*/function (_BaseAppointmentsStra) {\n  _inherits(VerticalRenderingStrategy, _BaseAppointmentsStra);\n  function VerticalRenderingStrategy() {\n    _classCallCheck(this, VerticalRenderingStrategy);\n    return _possibleConstructorReturn(this, _getPrototypeOf(VerticalRenderingStrategy).apply(this, arguments));\n  }\n  _createClass(VerticalRenderingStrategy, [{\n    key: \"getDeltaTime\",\n    value: function getDeltaTime(args, initialSize, appointment) {\n      var deltaTime = 0;\n      if (this.isAllDay(appointment)) {\n        deltaTime = this._getDeltaWidth(args, initialSize) * toMs(\"day\");\n      } else {\n        var deltaHeight = args.height - initialSize.height;\n        deltaTime = toMs(\"minute\") * Math.round(deltaHeight / this.cellHeight * this.cellDurationInMinutes);\n      }\n      return deltaTime;\n    }\n  }, {\n    key: \"_correctCollectorCoordinatesInAdaptive\",\n    value: function _correctCollectorCoordinatesInAdaptive(coordinates, isAllDay) {\n      if (isAllDay) {\n        _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"_correctCollectorCoordinatesInAdaptive\", this).call(this, coordinates, isAllDay);\n      } else if (0 === this._getMaxAppointmentCountPerCellByType()) {\n        var cellHeight = this.cellHeight;\n        var cellWidth = this.cellWidth;\n        coordinates.top += (cellHeight - this.getDropDownButtonAdaptiveSize()) / 2;\n        coordinates.left += (cellWidth - this.getDropDownButtonAdaptiveSize()) / 2;\n      }\n    }\n  }, {\n    key: \"getAppointmentGeometry\",\n    value: function getAppointmentGeometry(coordinates) {\n      var geometry = null;\n      if (coordinates.allDay) {\n        geometry = this._getAllDayAppointmentGeometry(coordinates);\n      } else {\n        geometry = this.isAdaptive && coordinates.isCompact ? this._getAdaptiveGeometry(coordinates) : this._getVerticalAppointmentGeometry(coordinates);\n      }\n      return _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"getAppointmentGeometry\", this).call(this, geometry);\n    }\n  }, {\n    key: \"_getAdaptiveGeometry\",\n    value: function _getAdaptiveGeometry(coordinates) {\n      var config = this._calculateGeometryConfig(coordinates);\n      return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset);\n    }\n  }, {\n    key: \"_getItemPosition\",\n    value: function _getItemPosition(appointment) {\n      var allDay = this.isAllDay(appointment);\n      if (allDay) {\n        return _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"_getItemPosition\", this).call(this, appointment);\n      }\n      var adapter = createAppointmentAdapter(appointment, this.dataAccessors, this.timeZoneCalculator);\n      var isRecurring = !!adapter.recurrenceRule;\n      var appointmentStartDate = adapter.calculateStartDate(\"toGrid\");\n      var appointmentEndDate = adapter.calculateEndDate(\"toGrid\");\n      var appointmentDuration = appointmentEndDate - appointmentStartDate;\n      var appointmentBeginInCurrentView = this.options.startViewDate < appointmentStartDate;\n      var isAppointmentTakesSeveralDays = !timeZoneUtils.isSameAppointmentDates(appointmentStartDate, appointmentEndDate);\n      var settings = this.generateAppointmentSettings(appointment);\n      var result = [];\n      for (var j = 0; j < settings.length; j++) {\n        var currentSetting = settings[j];\n        var height = this.calculateAppointmentHeight(appointment, currentSetting);\n        var width = this.calculateAppointmentWidth(appointment, currentSetting);\n        var resultHeight = height;\n        var appointmentReduced = null;\n        var multiDaysAppointmentParts = [];\n        var currentMaxAllowedPosition = currentSetting.vMax;\n        if (this._isMultiViewAppointment(currentSetting, height) || isAppointmentTakesSeveralDays && !isRecurring) {\n          var trimmedStartDate = dateUtils.trimTime(appointmentStartDate);\n          var trimmedSettingStartDate = dateUtils.trimTime(currentSetting.info.appointment.startDate);\n          var reduceHead = trimmedStartDate <= trimmedSettingStartDate || isRecurring;\n          if (reduceHead) {\n            resultHeight = this._reduceMultiDayAppointment(height, {\n              top: currentSetting.top,\n              bottom: currentMaxAllowedPosition\n            });\n            multiDaysAppointmentParts = this._getAppointmentParts({\n              sourceAppointmentHeight: height,\n              reducedHeight: resultHeight,\n              width: width\n            }, currentSetting);\n          }\n          var _currentSetting$info$ = currentSetting.info.appointment,\n            currentSettingStartDate = _currentSetting$info$.startDate,\n            currentSettingNormalizedEndDate = _currentSetting$info$.normalizedEndDate;\n          var currentSettingDuration = currentSettingNormalizedEndDate - currentSettingStartDate;\n          var hasNextParts = currentSettingDuration < appointmentDuration;\n          appointmentReduced = hasNextParts ? appointmentBeginInCurrentView ? \"head\" : \"body\" : appointmentBeginInCurrentView ? \"head\" : \"tail\";\n        }\n        extend(currentSetting, {\n          height: resultHeight,\n          width: width,\n          allDay: allDay,\n          appointmentReduced: appointmentReduced\n        });\n        result = this._getAppointmentPartsPosition(multiDaysAppointmentParts, currentSetting, result);\n      }\n      return result;\n    }\n  }, {\n    key: \"_isMultiViewAppointment\",\n    value: function _isMultiViewAppointment(_ref, height) {\n      var vMax = _ref.vMax,\n        top = _ref.top;\n      var fullAppointmentHeight = roundFloatPart(height, 2);\n      var remainingHeight = roundFloatPart(vMax - top, 2);\n      return fullAppointmentHeight > remainingHeight;\n    }\n  }, {\n    key: \"_reduceMultiDayAppointment\",\n    value: function _reduceMultiDayAppointment(sourceAppointmentHeight, bound) {\n      return Math.min(sourceAppointmentHeight, bound.bottom - Math.floor(bound.top));\n    }\n  }, {\n    key: \"_getGroupHeight\",\n    value: function _getGroupHeight() {\n      return this.cellHeight * this.rowCount;\n    }\n  }, {\n    key: \"_getGroupTopOffset\",\n    value: function _getGroupTopOffset(appointmentSettings) {\n      var groupIndex = appointmentSettings.groupIndex;\n      var groupTop = Math.max(0, this.positionHelper.getGroupTop({\n        groupIndex: groupIndex,\n        showAllDayPanel: this.showAllDayPanel,\n        isGroupedAllDayPanel: this.isGroupedAllDayPanel\n      }));\n      var allDayPanelOffset = this.positionHelper.getOffsetByAllDayPanel({\n        groupIndex: groupIndex,\n        supportAllDayRow: this.allDaySupported(),\n        showAllDayPanel: this.showAllDayPanel\n      });\n      var appointmentGroupTopOffset = appointmentSettings.top - groupTop - allDayPanelOffset;\n      return appointmentGroupTopOffset;\n    }\n  }, {\n    key: \"_getTailHeight\",\n    value: function _getTailHeight(appointmentGeometry, appointmentSettings) {\n      if (!this.isVirtualScrolling) {\n        return appointmentGeometry.sourceAppointmentHeight - appointmentGeometry.reducedHeight;\n      }\n      var appointmentGroupTopOffset = this._getGroupTopOffset(appointmentSettings);\n      var sourceAppointmentHeight = appointmentGeometry.sourceAppointmentHeight;\n      var groupHeight = this._getGroupHeight();\n      var tailHeight = appointmentGroupTopOffset + sourceAppointmentHeight - groupHeight;\n      return tailHeight;\n    }\n  }, {\n    key: \"_getAppointmentParts\",\n    value: function _getAppointmentParts(appointmentGeometry, appointmentSettings) {\n      var width = appointmentGeometry.width;\n      var result = [];\n      var currentPartTop = Math.max(0, this.positionHelper.getGroupTop({\n        groupIndex: appointmentSettings.groupIndex,\n        showAllDayPanel: this.showAllDayPanel,\n        isGroupedAllDayPanel: this.isGroupedAllDayPanel\n      }));\n      var cellsDiff = this.isGroupedByDate ? this.groupCount : 1;\n      var offset = this.cellWidth * cellsDiff;\n      var allDayPanelOffset = this.positionHelper.getOffsetByAllDayPanel({\n        groupIndex: appointmentSettings.groupIndex,\n        supportAllDayRow: this.allDaySupported(),\n        showAllDayPanel: this.showAllDayPanel\n      });\n      currentPartTop += allDayPanelOffset;\n      var minHeight = this.getAppointmentMinSize();\n      var vMax = appointmentSettings.vMax,\n        hMax = appointmentSettings.hMax;\n      var hasTailPart = this.options.endViewDate > appointmentSettings.info.appointment.endDate;\n      var left = Math.round(appointmentSettings.left + offset);\n      var tailHeight = this._getTailHeight(appointmentGeometry, appointmentSettings);\n      while (tailHeight > 0 && left < hMax) {\n        tailHeight = Math.max(minHeight, tailHeight);\n        var columnIndex = appointmentSettings.columnIndex + cellsDiff;\n        var height = Math.min(tailHeight, vMax);\n        result.push(_extends({}, appointmentSettings, {\n          top: currentPartTop,\n          left: left,\n          height: height,\n          width: width,\n          appointmentReduced: \"body\",\n          rowIndex: 0,\n          columnIndex: columnIndex\n        }));\n        left += offset;\n        tailHeight -= vMax;\n      }\n      if (hasTailPart && result.length > 0) {\n        result[result.length - 1].appointmentReduced = \"tail\";\n      }\n      return result;\n    }\n  }, {\n    key: \"_getMinuteHeight\",\n    value: function _getMinuteHeight() {\n      return this.cellHeight / this.cellDurationInMinutes;\n    }\n  }, {\n    key: \"_getCompactLeftCoordinate\",\n    value: function _getCompactLeftCoordinate(itemLeft, index) {\n      var cellWidth = this.cellWidth || this.getAppointmentMinSize();\n      return itemLeft + (1 + cellWidth) * index;\n    }\n  }, {\n    key: \"_getVerticalAppointmentGeometry\",\n    value: function _getVerticalAppointmentGeometry(coordinates) {\n      var config = this._calculateVerticalGeometryConfig(coordinates);\n      return this._customizeVerticalCoordinates(coordinates, config.width, config.appointmentCountPerCell, config.offset);\n    }\n  }, {\n    key: \"_customizeVerticalCoordinates\",\n    value: function _customizeVerticalCoordinates(coordinates, width, appointmentCountPerCell, topOffset, isAllDay) {\n      var appointmentWidth = Math.max(width / appointmentCountPerCell, width / coordinates.count);\n      var height = coordinates.height;\n      var appointmentLeft = coordinates.left + coordinates.index * appointmentWidth;\n      var top = coordinates.top;\n      if (coordinates.isCompact) {\n        this._markAppointmentAsVirtual(coordinates, isAllDay);\n      }\n      return {\n        height: height,\n        width: appointmentWidth,\n        top: top,\n        left: appointmentLeft,\n        empty: this._isAppointmentEmpty(height, width)\n      };\n    }\n  }, {\n    key: \"_calculateVerticalGeometryConfig\",\n    value: function _calculateVerticalGeometryConfig(coordinates) {\n      var overlappingMode = this.maxAppointmentsPerCell;\n      var offsets = this._getOffsets();\n      var appointmentDefaultOffset = this._getAppointmentDefaultOffset();\n      var appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);\n      var ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);\n      var maxWidth = this._getMaxWidth();\n      if (!appointmentCountPerCell) {\n        appointmentCountPerCell = coordinates.count;\n        ratio = (maxWidth - offsets.unlimited) / maxWidth;\n      }\n      var topOffset = (1 - ratio) * maxWidth;\n      if (\"auto\" === overlappingMode || isNumeric(overlappingMode)) {\n        ratio = 1;\n        maxWidth -= appointmentDefaultOffset;\n        topOffset = 0;\n      }\n      return {\n        width: ratio * maxWidth,\n        appointmentCountPerCell: appointmentCountPerCell,\n        offset: topOffset\n      };\n    }\n  }, {\n    key: \"_getMaxWidth\",\n    value: function _getMaxWidth() {\n      return this.cellWidth;\n    }\n  }, {\n    key: \"isAllDay\",\n    value: function isAllDay(appointmentData) {\n      return getAppointmentTakesAllDay(createAppointmentAdapter(appointmentData, this.dataAccessors, this.timeZoneCalculator), this.startDayHour, this.endDayHour, this.allDayPanelMode);\n    }\n  }, {\n    key: \"_getAppointmentMaxWidth\",\n    value: function _getAppointmentMaxWidth() {\n      return this.cellWidth - this._getAppointmentDefaultOffset();\n    }\n  }, {\n    key: \"calculateAppointmentWidth\",\n    value: function calculateAppointmentWidth(appointment, position) {\n      if (!this.isAllDay(appointment)) {\n        return 0;\n      }\n      var startDate = dateUtils.trimTime(position.info.appointment.startDate);\n      var normalizedEndDate = position.info.appointment.normalizedEndDate;\n      var cellWidth = this.cellWidth || this.getAppointmentMinSize();\n      var durationInHours = (normalizedEndDate.getTime() - startDate.getTime()) / toMs(\"hour\");\n      var skippedHours = getSkippedHoursInRange(position.info.appointment.startDate, position.info.appointment.endDate, this.viewDataProvider);\n      var width = Math.ceil((durationInHours - skippedHours) / 24) * cellWidth;\n      width = this.cropAppointmentWidth(width, cellWidth);\n      return width;\n    }\n  }, {\n    key: \"calculateAppointmentHeight\",\n    value: function calculateAppointmentHeight(appointment, position) {\n      if (this.isAllDay(appointment)) {\n        return 0;\n      }\n      var startDate = position.info.appointment.startDate;\n      var normalizedEndDate = position.info.appointment.normalizedEndDate;\n      var allDay = ExpressionUtils.getField(this.dataAccessors, \"allDay\", appointment);\n      var duration = this.getAppointmentDurationInMs(startDate, normalizedEndDate, allDay);\n      var durationInMinutes = this._adjustDurationByDaylightDiff(duration, startDate, normalizedEndDate) / toMs(\"minute\");\n      var height = durationInMinutes * this._getMinuteHeight();\n      return height;\n    }\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      return \"vertical\";\n    }\n  }, {\n    key: \"_sortCondition\",\n    value: function _sortCondition(a, b) {\n      var allDayCondition = a.allDay - b.allDay;\n      var isAllDay = a.allDay && b.allDay;\n      var condition = \"vertical\" === this.groupOrientation && isAllDay ? this._columnCondition(a, b) : this._rowCondition(a, b);\n      return allDayCondition ? allDayCondition : condition;\n    }\n  }, {\n    key: \"allDaySupported\",\n    value: function allDaySupported() {\n      return true;\n    }\n  }, {\n    key: \"_getAllDayAppointmentGeometry\",\n    value: function _getAllDayAppointmentGeometry(coordinates) {\n      var config = this._calculateGeometryConfig(coordinates);\n      return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset, true);\n    }\n  }, {\n    key: \"_calculateGeometryConfig\",\n    value: function _calculateGeometryConfig(coordinates) {\n      if (!this.allowResizing || !this.allowAllDayResizing) {\n        coordinates.skipResizing = true;\n      }\n      var config = _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"_calculateGeometryConfig\", this).call(this, coordinates);\n      var minAppointmentCountPerCell = Math.min(config.appointmentCountPerCell, this._getDynamicAppointmentCountPerCell().allDay);\n      if (coordinates.allDay && coordinates.count <= minAppointmentCountPerCell) {\n        config.offset = 0;\n      }\n      return config;\n    }\n  }, {\n    key: \"_getAppointmentCount\",\n    value: function _getAppointmentCount(overlappingMode, coordinates) {\n      return \"auto\" !== overlappingMode && 1 === coordinates.count && !isNumeric(overlappingMode) ? coordinates.count : this._getMaxAppointmentCountPerCellByType(coordinates.allDay);\n    }\n  }, {\n    key: \"_getDefaultRatio\",\n    value: function _getDefaultRatio(coordinates, appointmentCountPerCell) {\n      return coordinates.count > this.appointmentCountPerCell ? .65 : 1;\n    }\n  }, {\n    key: \"_getOffsets\",\n    value: function _getOffsets() {\n      return {\n        unlimited: ALLDAY_APPOINTMENT_MIN_VERTICAL_OFFSET,\n        auto: ALLDAY_APPOINTMENT_MAX_VERTICAL_OFFSET\n      };\n    }\n  }, {\n    key: \"_getMaxHeight\",\n    value: function _getMaxHeight() {\n      return this.allDayHeight || this.getAppointmentMinSize();\n    }\n  }, {\n    key: \"_needVerticalGroupBounds\",\n    value: function _needVerticalGroupBounds(allDay) {\n      return !allDay;\n    }\n  }, {\n    key: \"_needHorizontalGroupBounds\",\n    value: function _needHorizontalGroupBounds() {\n      return false;\n    }\n  }, {\n    key: \"getPositionShift\",\n    value: function getPositionShift(timeShift, isAllDay) {\n      if (!isAllDay && this.isAdaptive && 0 === this._getMaxAppointmentCountPerCellByType(isAllDay)) {\n        return {\n          top: 0,\n          left: 0,\n          cellPosition: 0\n        };\n      }\n      return _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"getPositionShift\", this).call(this, timeShift, isAllDay);\n    }\n  }]);\n  return VerticalRenderingStrategy;\n}(BaseAppointmentsStrategy);\nexport default VerticalRenderingStrategy;","map":null,"metadata":{},"sourceType":"module"}